
        function _base64ToArrayBuffer(base64) {
            var binary_string = window.atob(base64);
            var len = binary_string.length;
            var bytes = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function _arrayBufferToBase64( buffer ) {
          var binary = '';
          var bytes = new Uint8Array( buffer );
          var len = bytes.byteLength;
          for (var i = 0; i < len; i++) {
             binary += String.fromCharCode( bytes[ i ] );
          }
          return window.btoa( binary );
        }

        document.addEventListener("DOMContentLoaded", function() {
            var old_prefilter = jQuery.htmlPrefilter;

            jQuery.htmlPrefilter = function(v) {
            
                var regs = [
                    /<a[^>]*href="(?<url>[^"]*)"[^>]*>/gi,
                    /<img[^>]*src="(?<url>[^"]*)"\/?>/gi,
                    /<source[^>]*src="(?<url>[^"]*)"/gi
                ];
                
                var replaces = {};

                for (i in regs)
                {
                    reg = regs[i];

                    var m = true;
                    var n = 0;
                    while (m && n < 100)
                    {
                        n += 1;
                        
                        m = reg.exec(v);
                        if (m)
                        {
                            if (m['groups'] && m['groups']['url'])
                            {
                                var url = m['groups']['url'];
                                if (server_data.hasOwnProperty(url))
                                {
                                    console.log(`Added url:${url} to be replaced with data of ${server_data[url].length} bytes length`);
                                    replaces[url] = server_data[url];                                    
                                }
                            }
                        }
                    }
                }
                
                for (let src in replaces)
                {
                    let dest = replaces[src];
                    v = v.replace(src, dest);
                }

                return old_prefilter(v);
            };
        });

        var server_data={
 "data/behaviors.csv": "\"Epic\",\"Feature\",\"Story\",\"FAILED\",\"BROKEN\",\"PASSED\",\"SKIPPED\",\"UNKNOWN\"\n\"\",\"\",\"\",\"2\",\"4\",\"20\",\"0\",\"0\"\n", 
 "data/behaviors.json": "{\"uid\":\"b1a8273437954620fa374b796ffaacdd\",\"name\":\"behaviors\",\"children\":[{\"name\":\"test_login[result0]\",\"uid\":\"855ec7744f974935\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"broken\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result1]\",\"uid\":\"37e0df3b92f127b0\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"broken\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result2]\",\"uid\":\"4d5227dfd64c8c2f\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"broken\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login\",\"uid\":\"ac58a6a18af5deec\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"broken\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":5,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]},{\"name\":\"test_register[result0]\",\"uid\":\"7cab27e631aff5d2\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"failed\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result1]\",\"uid\":\"7d2df5c839a0e516\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result2]\",\"uid\":\"9983dff8d8f5cc9e\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_getsAddressList[result0]\",\"uid\":\"1561815528981bde\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result0]\",\"uid\":\"d5a5b2c179710c79\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result1]\",\"uid\":\"c02bfde9815c6999\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result0]\",\"uid\":\"2804ffcd9a1cd236\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result1]\",\"uid\":\"2943596d6e1f5d\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result0]\",\"uid\":\"e4749b9164c6442c\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result1]\",\"uid\":\"9b47a930887b90e6\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result0]\",\"uid\":\"629bc8ce5a745b9d\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result1]\",\"uid\":\"41358ff5883d29f4\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getDeafultAddress[result0]\",\"uid\":\"86d917d5f43504c4\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_submit[result0]\",\"uid\":\"fc2c79a47e8a0be2\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_submit[result1]\",\"uid\":\"6328afffd0309615\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"failed\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_getall[result0]\",\"uid\":\"dde8b1bbd7520535\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"c1ab83aa5974a5fe\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"3eb22ea9f8d3f236\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"f83303d47c163767\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"efbba17f563634ff\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res1]\",\"uid\":\"4506d4abe61d6cde\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"d488b61a1a8655ff\",\"parentUid\":\"b1a8273437954620fa374b796ffaacdd\",\"status\":\"passed\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]}]}", 
 "data/categories.csv": "\"Category\",\"FAILED\",\"BROKEN\",\"PASSED\",\"SKIPPED\",\"UNKNOWN\"\n\"Product defects\",\"2\",\"0\",\"0\",\"0\",\"0\"\n\"Test defects\",\"0\",\"4\",\"0\",\"0\",\"0\"\n", 
 "data/categories.json": "{\"uid\":\"4b4757e66a1912dae1a509f688f20b0f\",\"name\":\"categories\",\"children\":[{\"name\":\"Test defects\",\"children\":[{\"name\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"children\":[{\"name\":\"test_login[result0]\",\"uid\":\"855ec7744f974935\",\"parentUid\":\"cd80505f89dd893665d19b861c6dd328\",\"status\":\"broken\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]}],\"uid\":\"cd80505f89dd893665d19b861c6dd328\"},{\"name\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"children\":[{\"name\":\"test_login[result1]\",\"uid\":\"37e0df3b92f127b0\",\"parentUid\":\"7c23fee221db0d9448fe1a481f822c87\",\"status\":\"broken\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]}],\"uid\":\"7c23fee221db0d9448fe1a481f822c87\"},{\"name\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"children\":[{\"name\":\"test_login[result2]\",\"uid\":\"4d5227dfd64c8c2f\",\"parentUid\":\"a6db092a4d75452b6d934de66ed65501\",\"status\":\"broken\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]}],\"uid\":\"a6db092a4d75452b6d934de66ed65501\"},{\"name\":\"TypeError: list indices must be integers or slices, not str\",\"children\":[{\"name\":\"test_login\",\"uid\":\"ac58a6a18af5deec\",\"parentUid\":\"a6ca840760d68beef4d0b02ac437317c\",\"status\":\"broken\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":5,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]}],\"uid\":\"a6ca840760d68beef4d0b02ac437317c\"}],\"uid\":\"bdbf199525818fae7a8651db9eafe741\"},{\"name\":\"Product defects\",\"children\":[{\"name\":\"AssertionError: assert 0 == 1001\",\"children\":[{\"name\":\"test_register[result0]\",\"uid\":\"7cab27e631aff5d2\",\"parentUid\":\"c81bdc355b5c70fced495d9da7b8200b\",\"status\":\"failed\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]}],\"uid\":\"c81bdc355b5c70fced495d9da7b8200b\"},{\"name\":\"AssertionError: assert 30001 == 0\",\"children\":[{\"name\":\"test_order_submit[result1]\",\"uid\":\"6328afffd0309615\",\"parentUid\":\"a422bffc4768a714eed56a6eb56ffcf2\",\"status\":\"failed\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]}],\"uid\":\"a422bffc4768a714eed56a6eb56ffcf2\"}],\"uid\":\"8fb3a91ba5aaf9de24cc8a92edc82b5d\"}]}", 
 "data/packages.json": "{\"uid\":\"83edc06c07f9ae9e47eb6dd1b683e4e2\",\"name\":\"packages\",\"children\":[{\"name\":\"testcases\",\"children\":[{\"name\":\"test_user\",\"children\":[{\"name\":\"test_login[result0]\",\"uid\":\"855ec7744f974935\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"broken\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result1]\",\"uid\":\"37e0df3b92f127b0\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"broken\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result2]\",\"uid\":\"4d5227dfd64c8c2f\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"broken\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login\",\"uid\":\"ac58a6a18af5deec\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"broken\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":5,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]},{\"name\":\"test_register[result0]\",\"uid\":\"7cab27e631aff5d2\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"failed\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result1]\",\"uid\":\"7d2df5c839a0e516\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"passed\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result2]\",\"uid\":\"9983dff8d8f5cc9e\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"passed\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"c1ab83aa5974a5fe\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"passed\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"3eb22ea9f8d3f236\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"passed\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"f83303d47c163767\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"passed\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"efbba17f563634ff\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"passed\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res1]\",\"uid\":\"4506d4abe61d6cde\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"passed\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"d488b61a1a8655ff\",\"parentUid\":\"8b4bf9027a960b34b608566463f95b83\",\"status\":\"passed\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]}],\"uid\":\"8b4bf9027a960b34b608566463f95b83\"},{\"name\":\"test_address\",\"children\":[{\"name\":\"test_getsAddressList[result0]\",\"uid\":\"1561815528981bde\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result0]\",\"uid\":\"d5a5b2c179710c79\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result1]\",\"uid\":\"c02bfde9815c6999\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result0]\",\"uid\":\"2804ffcd9a1cd236\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result1]\",\"uid\":\"2943596d6e1f5d\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result0]\",\"uid\":\"e4749b9164c6442c\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result1]\",\"uid\":\"9b47a930887b90e6\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result0]\",\"uid\":\"629bc8ce5a745b9d\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result1]\",\"uid\":\"41358ff5883d29f4\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getDeafultAddress[result0]\",\"uid\":\"86d917d5f43504c4\",\"parentUid\":\"ab4da77f092200710b96a248120f5f9c\",\"status\":\"passed\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]}],\"uid\":\"ab4da77f092200710b96a248120f5f9c\"},{\"name\":\"test_order\",\"children\":[{\"name\":\"test_order_submit[result0]\",\"uid\":\"fc2c79a47e8a0be2\",\"parentUid\":\"61f43bfb92c2e324219fa76a1f51c1bf\",\"status\":\"passed\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_submit[result1]\",\"uid\":\"6328afffd0309615\",\"parentUid\":\"61f43bfb92c2e324219fa76a1f51c1bf\",\"status\":\"failed\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_getall[result0]\",\"uid\":\"dde8b1bbd7520535\",\"parentUid\":\"61f43bfb92c2e324219fa76a1f51c1bf\",\"status\":\"passed\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"],\"tags\":[]}],\"uid\":\"61f43bfb92c2e324219fa76a1f51c1bf\"}],\"uid\":\"141fa05f02bf329144b0086cf92149a8\"}]}", 
 "data/suites.csv": "\"Status\",\"Start Time\",\"Stop Time\",\"Duration in ms\",\"Parent Suite\",\"Suite\",\"Sub Suite\",\"Test Class\",\"Test Method\",\"Name\",\"Description\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"8\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_addNewAddress[result1]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"7\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_updateAddressByAid[result0]\",\"\"\n\"failed\",\"Thu Jan 25 17:26:25 CST 2024\",\"Thu Jan 25 17:26:25 CST 2024\",\"19\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_register[result0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"6\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_login[res0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"5\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_updateAddressByAid[result1]\",\"\"\n\"failed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"8\",\"testcases\",\"test_order\",\"\",\"\",\"\",\"test_order_submit[result1]\",\"\"\n\"broken\",\"Thu Jan 25 02:24:18 CST 2024\",\"Thu Jan 25 02:24:18 CST 2024\",\"0\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_login\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"6\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_getDeafultAddress[result0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"5\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_getAddressByAid[result0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"21\",\"testcases\",\"test_order\",\"\",\"\",\"\",\"test_order_getall[result0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"7\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_addNewAddress[result0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"5\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_delAddressByAid[result1]\",\"\"\n\"broken\",\"Tue Jan 23 23:42:47 CST 2024\",\"Tue Jan 23 23:42:49 CST 2024\",\"2018\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_login[result2]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"5\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_login[res2]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"5\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_register[res0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"8\",\"testcases\",\"test_order\",\"\",\"\",\"\",\"test_order_submit[result0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"6\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_register[res1]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"4\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_getAddressByAid[result1]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"6\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_getsAddressList[result0]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"5\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_login[res1]\",\"\"\n\"passed\",\"Thu Jan 25 17:26:25 CST 2024\",\"Thu Jan 25 17:26:25 CST 2024\",\"5\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_register[result2]\",\"\"\n\"passed\",\"Thu Jan 25 17:26:25 CST 2024\",\"Thu Jan 25 17:26:25 CST 2024\",\"22\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_register[result1]\",\"\"\n\"broken\",\"Tue Jan 23 23:42:45 CST 2024\",\"Tue Jan 23 23:42:47 CST 2024\",\"2004\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_login[result1]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"6\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_register[res2]\",\"\"\n\"passed\",\"Thu Jan 25 17:51:27 CST 2024\",\"Thu Jan 25 17:51:27 CST 2024\",\"5\",\"testcases\",\"test_address\",\"\",\"\",\"\",\"test_delAddressByAid[result0]\",\"\"\n\"broken\",\"Tue Jan 23 23:42:43 CST 2024\",\"Tue Jan 23 23:42:45 CST 2024\",\"2014\",\"testcases\",\"test_user\",\"\",\"\",\"\",\"test_login[result0]\",\"\"\n", 
 "data/suites.json": "{\"uid\":\"98d3104e051c652961429bf95fa0b5d6\",\"name\":\"suites\",\"children\":[{\"name\":\"testcases\",\"children\":[{\"name\":\"test_user\",\"children\":[{\"name\":\"test_login[result0]\",\"uid\":\"855ec7744f974935\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"broken\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result1]\",\"uid\":\"37e0df3b92f127b0\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"broken\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result2]\",\"uid\":\"4d5227dfd64c8c2f\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"broken\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login\",\"uid\":\"ac58a6a18af5deec\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"broken\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":5,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]},{\"name\":\"test_register[result0]\",\"uid\":\"7cab27e631aff5d2\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"failed\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result1]\",\"uid\":\"7d2df5c839a0e516\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"passed\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result2]\",\"uid\":\"9983dff8d8f5cc9e\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"passed\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"c1ab83aa5974a5fe\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"passed\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"3eb22ea9f8d3f236\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"passed\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"f83303d47c163767\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"passed\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"efbba17f563634ff\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"passed\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res1]\",\"uid\":\"4506d4abe61d6cde\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"passed\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"d488b61a1a8655ff\",\"parentUid\":\"b967d4218501c29b1bf540f63a1c2b62\",\"status\":\"passed\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]}],\"uid\":\"b967d4218501c29b1bf540f63a1c2b62\"},{\"name\":\"test_address\",\"children\":[{\"name\":\"test_getsAddressList[result0]\",\"uid\":\"1561815528981bde\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result0]\",\"uid\":\"d5a5b2c179710c79\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result1]\",\"uid\":\"c02bfde9815c6999\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result0]\",\"uid\":\"2804ffcd9a1cd236\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result1]\",\"uid\":\"2943596d6e1f5d\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result0]\",\"uid\":\"e4749b9164c6442c\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result1]\",\"uid\":\"9b47a930887b90e6\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result0]\",\"uid\":\"629bc8ce5a745b9d\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result1]\",\"uid\":\"41358ff5883d29f4\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getDeafultAddress[result0]\",\"uid\":\"86d917d5f43504c4\",\"parentUid\":\"063a8b2230b51e2a472f7a015d86c641\",\"status\":\"passed\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]}],\"uid\":\"063a8b2230b51e2a472f7a015d86c641\"},{\"name\":\"test_order\",\"children\":[{\"name\":\"test_order_submit[result0]\",\"uid\":\"fc2c79a47e8a0be2\",\"parentUid\":\"ef671b1aa808a6767c02cdf6e8e0d38e\",\"status\":\"passed\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_submit[result1]\",\"uid\":\"6328afffd0309615\",\"parentUid\":\"ef671b1aa808a6767c02cdf6e8e0d38e\",\"status\":\"failed\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_getall[result0]\",\"uid\":\"dde8b1bbd7520535\",\"parentUid\":\"ef671b1aa808a6767c02cdf6e8e0d38e\",\"status\":\"passed\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"],\"tags\":[]}],\"uid\":\"ef671b1aa808a6767c02cdf6e8e0d38e\"}],\"uid\":\"b51346658ccdb9db01a6b5f6c12deab1\"}]}", 
 "data/timeline.json": "{\"uid\":\"ab17fc5a4eb3bca4b216b548c7f9fcbc\",\"name\":\"timeline\",\"children\":[{\"name\":\"DESKTOP-061EAN7\",\"children\":[{\"name\":\"16060-MainThread\",\"children\":[{\"name\":\"test_order_submit[result1]\",\"uid\":\"829f1fa11d3b9d89\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648143809,\"stop\":1705648143809,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'fail_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[result1]\",\"uid\":\"a4fcf360eb4a29ad\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648148480,\"stop\":1705648152538,\"duration\":4058},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result1]\",\"uid\":\"2604ce0ea6dcf02e\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648143415,\"stop\":1705648143415,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('009', 'fail-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result0]\",\"uid\":\"57b26aeafef0c82\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648142636,\"stop\":1705648142636,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'succ-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[result2]\",\"uid\":\"12e98e1e9a8f5bbb\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"passed\",\"time\":{\"start\":1705648159530,\"stop\":1705648159538,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result1]\",\"uid\":\"7d6899310bfd0f72\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648142974,\"stop\":1705648142974,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getDeafultAddress[result0]\",\"uid\":\"d1e3f0d1cad9ed5\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648143538,\"stop\":1705648143538,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('010', 'succ-getDefaultAddress', 'address', 'localhost:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[result0]\",\"uid\":\"777ee1a42b2d201a\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"failed\",\"time\":{\"start\":1705648156897,\"stop\":1705648159509,\"duration\":2612},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result0]\",\"uid\":\"db71788f163efb6b\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648143087,\"stop\":1705648143087,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'succ-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[result2]\",\"uid\":\"48ac857847062f9\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648152669,\"stop\":1705648156790,\"duration\":4121},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result1]\",\"uid\":\"fdbdaea3ad155ee1\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648142740,\"stop\":1705648142740,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'fail-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_getall[result0]\",\"uid\":\"b8627919718d53a8\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648144000,\"stop\":1705648144000,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'succ_order_getAll', 'order', 'localhost:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result0]\",\"uid\":\"6240318d33740dc3\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648143312,\"stop\":1705648143312,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('008', 'succ-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[result0]\",\"uid\":\"58f88f2609cf025e\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648144134,\"stop\":1705648148235,\"duration\":4101},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_order_submit[result0]\",\"uid\":\"e48f4a8ea6ffe578\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648143659,\"stop\":1705648143659,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result0]\",\"uid\":\"dc332251f910a23b\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648142847,\"stop\":1705648142847,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-getAddressByAid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getsAddressList[result0]\",\"uid\":\"b0de72f0fe71afe3\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648138299,\"stop\":1705648138299,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-getAddressList', 'address', 'localhost:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[result1]\",\"uid\":\"45b81bc67a25584\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"passed\",\"time\":{\"start\":1705648159519,\"stop\":1705648159526,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result1]\",\"uid\":\"c5eb365d82d86cd5\",\"parentUid\":\"db0dec81cff1a55a054f9e24caddc1a1\",\"status\":\"broken\",\"time\":{\"start\":1705648143194,\"stop\":1705648143194,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('007', 'fail-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]}],\"uid\":\"db0dec81cff1a55a054f9e24caddc1a1\"},{\"name\":\"15864-MainThread\",\"children\":[{\"name\":\"test_register[result0]\",\"uid\":\"7cab27e631aff5d2\",\"parentUid\":\"103ce43d0620ee82570ba8b1d9a39ade\",\"status\":\"failed\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"7e2d167039e5082b\",\"parentUid\":\"103ce43d0620ee82570ba8b1d9a39ade\",\"status\":\"passed\",\"time\":{\"start\":1706174785095,\"stop\":1706174785100,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result2]\",\"uid\":\"9983dff8d8f5cc9e\",\"parentUid\":\"103ce43d0620ee82570ba8b1d9a39ade\",\"status\":\"passed\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"d306ab9e57f3b994\",\"parentUid\":\"103ce43d0620ee82570ba8b1d9a39ade\",\"status\":\"passed\",\"time\":{\"start\":1706174785086,\"stop\":1706174785092,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"37e228441c4c3f65\",\"parentUid\":\"103ce43d0620ee82570ba8b1d9a39ade\",\"status\":\"passed\",\"time\":{\"start\":1706174785076,\"stop\":1706174785084,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result1]\",\"uid\":\"7d2df5c839a0e516\",\"parentUid\":\"103ce43d0620ee82570ba8b1d9a39ade\",\"status\":\"passed\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]}],\"uid\":\"103ce43d0620ee82570ba8b1d9a39ade\"},{\"name\":\"10000-MainThread\",\"children\":[{\"name\":\"test_register[res0]\",\"uid\":\"8c81b6cfd82f2126\",\"parentUid\":\"bd525447ac48dbe81e5466cbd6411614\",\"status\":\"failed\",\"time\":{\"start\":1706175103835,\"stop\":1706175103840,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"d105b1c5083274ac\",\"parentUid\":\"bd525447ac48dbe81e5466cbd6411614\",\"status\":\"passed\",\"time\":{\"start\":1706175103974,\"stop\":1706175103979,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res1]\",\"uid\":\"e5fd9ed04dac6302\",\"parentUid\":\"bd525447ac48dbe81e5466cbd6411614\",\"status\":\"passed\",\"time\":{\"start\":1706175103964,\"stop\":1706175103970,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"44cdd8ea0e91484f\",\"parentUid\":\"bd525447ac48dbe81e5466cbd6411614\",\"status\":\"passed\",\"time\":{\"start\":1706175103821,\"stop\":1706175103826,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"d5f5676e825a95df\",\"parentUid\":\"bd525447ac48dbe81e5466cbd6411614\",\"status\":\"passed\",\"time\":{\"start\":1706175103811,\"stop\":1706175103818,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"a605a95d5e451326\",\"parentUid\":\"bd525447ac48dbe81e5466cbd6411614\",\"status\":\"passed\",\"time\":{\"start\":1706175103828,\"stop\":1706175103833,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]}],\"uid\":\"bd525447ac48dbe81e5466cbd6411614\"},{\"name\":\"9944-MainThread\",\"children\":[{\"name\":\"test_updateAddressByAid[result0]\",\"uid\":\"43a1ca1d96b6b40c\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024562169,\"stop\":1706024562169,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getsAddressList[result0]\",\"uid\":\"6ebed51a52a9b14b\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024559446,\"stop\":1706024559446,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[result0]\",\"uid\":\"9802d0da6fbd139f\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024569517,\"stop\":1706024571536,\"duration\":2019},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result0]\",\"uid\":\"8c63ea0716a5841c\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024561700,\"stop\":1706024561700,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[result2]\",\"uid\":\"bbe95b736bb987cd\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024573800,\"stop\":1706024575816,\"duration\":2016},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_getDeafultAddress[result0]\",\"uid\":\"21370f3ffbc5706\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024562593,\"stop\":1706024562593,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_submit[result0]\",\"uid\":\"d53f6d70a9c81d71\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024562709,\"stop\":1706024562709,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result1]\",\"uid\":\"59aa65b9076491\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024561805,\"stop\":1706024561805,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result0]\",\"uid\":\"7f25b47d29fdd0b8\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024562386,\"stop\":1706024562386,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result1]\",\"uid\":\"cf35e8a285e37e3c\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024562041,\"stop\":1706024562041,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result0]\",\"uid\":\"8b48dd6cfa60dcf1\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024561912,\"stop\":1706024561912,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result1]\",\"uid\":\"3765d8b8a8297a37\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024562272,\"stop\":1706024562272,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result1]\",\"uid\":\"847e00c0573453a3\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024562490,\"stop\":1706024562490,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_getall[result0]\",\"uid\":\"718f6be754103361\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024563001,\"stop\":1706024563001,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[result0]\",\"uid\":\"855ec7744f974935\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result1]\",\"uid\":\"37e0df3b92f127b0\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result2]\",\"uid\":\"4d5227dfd64c8c2f\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_order_submit[result1]\",\"uid\":\"62b801e2b9af5ae6\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024562842,\"stop\":1706024562842,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[result1]\",\"uid\":\"41b051b435ebef16\",\"parentUid\":\"d4f98817b7411272cf1659cc3602607d\",\"status\":\"broken\",\"time\":{\"start\":1706024571644,\"stop\":1706024573661,\"duration\":2017},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]}],\"uid\":\"d4f98817b7411272cf1659cc3602607d\"},{\"name\":\"5816-MainThread\",\"children\":[{\"name\":\"test_getsAddressList[result0]\",\"uid\":\"4a630288ecb6b240\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175265,\"stop\":1705648175287,\"duration\":22},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-getAddressList', 'address', 'localhost:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_getall[result0]\",\"uid\":\"ebd5a39f8564059c\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"broken\",\"time\":{\"start\":1705648175590,\"stop\":1705648175627,\"duration\":37},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'succ_order_getAll', 'order', 'localhost:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result1]\",\"uid\":\"3ec5a0aca74c5be2\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175346,\"stop\":1705648175352,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[result2]\",\"uid\":\"239377fefe608f69\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175660,\"stop\":1705648175666,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result0]\",\"uid\":\"eb5d88584cf2b3a5\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175637,\"stop\":1705648175646,\"duration\":9},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[result2]\",\"uid\":\"f310db1fc79fd9d5\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175697,\"stop\":1705648175704,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result1]\",\"uid\":\"f2cad0279515ab48\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175399,\"stop\":1705648175406,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('009', 'fail-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getDeafultAddress[result0]\",\"uid\":\"3e09bbfa1e0e9c33\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175409,\"stop\":1705648175417,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('010', 'succ-getDefaultAddress', 'address', 'localhost:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result0]\",\"uid\":\"bfe4fb7ad9acbe71\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175291,\"stop\":1705648175315,\"duration\":24},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'succ-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_submit[result1]\",\"uid\":\"44b23c4ed276fd3\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"failed\",\"time\":{\"start\":1705648175448,\"stop\":1705648175462,\"duration\":14},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'fail_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result0]\",\"uid\":\"b7c252fb9cb31156\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175385,\"stop\":1705648175394,\"duration\":9},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('008', 'succ-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result1]\",\"uid\":\"992369678935f076\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175373,\"stop\":1705648175380,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('007', 'fail-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result0]\",\"uid\":\"ca3dc772fc00a28e\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175333,\"stop\":1705648175342,\"duration\":9},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-getAddressByAid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result0]\",\"uid\":\"82d31ee73066ea4d\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175357,\"stop\":1705648175370,\"duration\":13},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'succ-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[result0]\",\"uid\":\"8862ef4f323535cf\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"failed\",\"time\":{\"start\":1705648175670,\"stop\":1705648175678,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result1]\",\"uid\":\"c646cb618c139539\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175318,\"stop\":1705648175330,\"duration\":12},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'fail-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[result1]\",\"uid\":\"f3ddde2fc782ecd\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175686,\"stop\":1705648175693,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[result1]\",\"uid\":\"a2fc69097003cf5c\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175650,\"stop\":1705648175656,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_order_submit[result0]\",\"uid\":\"463a5bd2f13d8a62\",\"parentUid\":\"fdd0790733a61e559a576dc461e7124e\",\"status\":\"passed\",\"time\":{\"start\":1705648175421,\"stop\":1705648175444,\"duration\":23},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"],\"tags\":[]}],\"uid\":\"fdd0790733a61e559a576dc461e7124e\"},{\"name\":\"16640-MainThread\",\"children\":[{\"name\":\"test_addNewAddress[result0]\",\"uid\":\"d5a5b2c179710c79\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result1]\",\"uid\":\"41358ff5883d29f4\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result0]\",\"uid\":\"629bc8ce5a745b9d\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_submit[result0]\",\"uid\":\"fc2c79a47e8a0be2\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result1]\",\"uid\":\"c02bfde9815c6999\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result0]\",\"uid\":\"2804ffcd9a1cd236\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_getall[result0]\",\"uid\":\"dde8b1bbd7520535\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result0]\",\"uid\":\"e4749b9164c6442c\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[res1]\",\"uid\":\"4506d4abe61d6cde\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result1]\",\"uid\":\"2943596d6e1f5d\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"f83303d47c163767\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"efbba17f563634ff\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":true,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"c1ab83aa5974a5fe\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_getsAddressList[result0]\",\"uid\":\"1561815528981bde\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"d488b61a1a8655ff\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result1]\",\"uid\":\"9b47a930887b90e6\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"3eb22ea9f8d3f236\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_order_submit[result1]\",\"uid\":\"6328afffd0309615\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"failed\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getDeafultAddress[result0]\",\"uid\":\"86d917d5f43504c4\",\"parentUid\":\"134d2e22014fd4161eaf99d299c5bef8\",\"status\":\"passed\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"parameters\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]}],\"uid\":\"134d2e22014fd4161eaf99d299c5bef8\"},{\"name\":\"19136-MainThread\",\"children\":[{\"name\":\"test_register[res2]\",\"uid\":\"bee54566c8d789a1\",\"parentUid\":\"8a5253b4e80bf2a2a380a9a79196cd83\",\"status\":\"passed\",\"time\":{\"start\":1706174957334,\"stop\":1706174957339,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"6668ec183649f57a\",\"parentUid\":\"8a5253b4e80bf2a2a380a9a79196cd83\",\"status\":\"passed\",\"time\":{\"start\":1706174957191,\"stop\":1706174957196,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"823e5019b6872caf\",\"parentUid\":\"8a5253b4e80bf2a2a380a9a79196cd83\",\"status\":\"passed\",\"time\":{\"start\":1706174957169,\"stop\":1706174957176,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res1]\",\"uid\":\"18600a6b8be8b31d\",\"parentUid\":\"8a5253b4e80bf2a2a380a9a79196cd83\",\"status\":\"passed\",\"time\":{\"start\":1706174957326,\"stop\":1706174957331,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"a42e21610ad5fe5b\",\"parentUid\":\"8a5253b4e80bf2a2a380a9a79196cd83\",\"status\":\"failed\",\"time\":{\"start\":1706174957199,\"stop\":1706174957205,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"23803f77f364625\",\"parentUid\":\"8a5253b4e80bf2a2a380a9a79196cd83\",\"status\":\"passed\",\"time\":{\"start\":1706174957178,\"stop\":1706174957183,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]}],\"uid\":\"8a5253b4e80bf2a2a380a9a79196cd83\"},{\"name\":\"3552-MainThread\",\"children\":[{\"name\":\"test_login[res2]\",\"uid\":\"32b06e0816e3d789\",\"parentUid\":\"0b80d8582234559c1015cbfc5866a3e3\",\"status\":\"passed\",\"time\":{\"start\":1706174692817,\"stop\":1706174692837,\"duration\":20},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"121364db5876c71d\",\"parentUid\":\"0b80d8582234559c1015cbfc5866a3e3\",\"status\":\"passed\",\"time\":{\"start\":1706174692804,\"stop\":1706174692812,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"d5b7145fa232099c\",\"parentUid\":\"0b80d8582234559c1015cbfc5866a3e3\",\"status\":\"passed\",\"time\":{\"start\":1706174692737,\"stop\":1706174692800,\"duration\":63},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]}],\"uid\":\"0b80d8582234559c1015cbfc5866a3e3\"},{\"name\":\"10508-MainThread\",\"children\":[{\"name\":\"test_register[res1]\",\"uid\":\"617a96d71a86238e\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012848,\"stop\":1706176012853,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result1]\",\"uid\":\"71d6c83f0b0714bf\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012518,\"stop\":1706176012522,\"duration\":4},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_submit[result1]\",\"uid\":\"9a2a474633554637\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"failed\",\"time\":{\"start\":1706176012611,\"stop\":1706176012619,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_order_getall[result0]\",\"uid\":\"f41f8f3868551db9\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"broken\",\"time\":{\"start\":1706176012732,\"stop\":1706176012773,\"duration\":41},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"8834dc40085b5894\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012840,\"stop\":1706176012846,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"7331757ec1317ef6\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012855,\"stop\":1706176012884,\"duration\":29},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result1]\",\"uid\":\"9ddd3edb6b9f1081\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012558,\"stop\":1706176012584,\"duration\":26},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result1]\",\"uid\":\"a726103007684711\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012497,\"stop\":1706176012508,\"duration\":11},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getsAddressList[result0]\",\"uid\":\"b3ee8f0eec85491b\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012461,\"stop\":1706176012477,\"duration\":16},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_delAddressByAid[result0]\",\"uid\":\"fe2fa76f95d27044\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012548,\"stop\":1706176012555,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getDeafultAddress[result0]\",\"uid\":\"fbd00a4f1636ad74\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012587,\"stop\":1706176012592,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_getAddressByAid[result0]\",\"uid\":\"68ccc2a7d497169c\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012510,\"stop\":1706176012516,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"58417ae0310d14ae\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012812,\"stop\":1706176012817,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_addNewAddress[result0]\",\"uid\":\"deccf557b865d595\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012480,\"stop\":1706176012494,\"duration\":14},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result0]\",\"uid\":\"93dbb0360b0f1050\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012525,\"stop\":1706176012534,\"duration\":9},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"19216d256fff3d6c\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012820,\"stop\":1706176012838,\"duration\":18},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"86453f582e605df4\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012780,\"stop\":1706176012809,\"duration\":29},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_order_submit[result0]\",\"uid\":\"a564f466e85d11d2\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012595,\"stop\":1706176012609,\"duration\":14},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"],\"tags\":[]},{\"name\":\"test_updateAddressByAid[result1]\",\"uid\":\"bef61f13e3947915\",\"parentUid\":\"29d263b74b81f45a3969fd8f10084225\",\"status\":\"passed\",\"time\":{\"start\":1706176012537,\"stop\":1706176012544,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"],\"tags\":[]}],\"uid\":\"29d263b74b81f45a3969fd8f10084225\"},{\"name\":\"8612-MainThread\",\"children\":[{\"name\":\"test_login[res0]\",\"uid\":\"24410c609482562\",\"parentUid\":\"590405c85b0dcc58a6236975e6758a97\",\"status\":\"passed\",\"time\":{\"start\":1706174984530,\"stop\":1706174984538,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"58295da410e8d5e0\",\"parentUid\":\"590405c85b0dcc58a6236975e6758a97\",\"status\":\"passed\",\"time\":{\"start\":1706174984713,\"stop\":1706174984719,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"2bf22827887d5029\",\"parentUid\":\"590405c85b0dcc58a6236975e6758a97\",\"status\":\"passed\",\"time\":{\"start\":1706174984546,\"stop\":1706174984552,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"4a1618bd78fb3d9a\",\"parentUid\":\"590405c85b0dcc58a6236975e6758a97\",\"status\":\"passed\",\"time\":{\"start\":1706174984556,\"stop\":1706174984562,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res1]\",\"uid\":\"c90469a05eb30fc3\",\"parentUid\":\"590405c85b0dcc58a6236975e6758a97\",\"status\":\"passed\",\"time\":{\"start\":1706174984706,\"stop\":1706174984710,\"duration\":4},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"ab68508ce08448\",\"parentUid\":\"590405c85b0dcc58a6236975e6758a97\",\"status\":\"failed\",\"time\":{\"start\":1706174984567,\"stop\":1706174984575,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]}],\"uid\":\"590405c85b0dcc58a6236975e6758a97\"},{\"name\":\"16972-MainThread\",\"children\":[{\"name\":\"test_login[res0]\",\"uid\":\"bc1d41551a77e65e\",\"parentUid\":\"4270f953aedd243be13de85aa84e67bf\",\"status\":\"broken\",\"time\":{\"start\":1706174616413,\"stop\":1706174616413,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"faf51b4aff6cbf19\",\"parentUid\":\"4270f953aedd243be13de85aa84e67bf\",\"status\":\"broken\",\"time\":{\"start\":1706174616544,\"stop\":1706174616544,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"5102fb4d71ab99d\",\"parentUid\":\"4270f953aedd243be13de85aa84e67bf\",\"status\":\"broken\",\"time\":{\"start\":1706174616539,\"stop\":1706174616539,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]}],\"uid\":\"4270f953aedd243be13de85aa84e67bf\"},{\"name\":\"16792-MainThread\",\"children\":[{\"name\":\"test_login\",\"uid\":\"faf5ca61d101cd27\",\"parentUid\":\"6325b70863dd1f7eec80fdf436ad6dcc\",\"status\":\"broken\",\"time\":{\"start\":1706120368292,\"stop\":1706120368292,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]}],\"uid\":\"6325b70863dd1f7eec80fdf436ad6dcc\"},{\"name\":\"3560-MainThread\",\"children\":[{\"name\":\"test_register[res1]\",\"uid\":\"6c14fc9a6931898e\",\"parentUid\":\"d8b039fe42debc8f09a74ffaf3f0d8aa\",\"status\":\"passed\",\"time\":{\"start\":1706174854149,\"stop\":1706174854154,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"4c56e82b4db47841\",\"parentUid\":\"d8b039fe42debc8f09a74ffaf3f0d8aa\",\"status\":\"passed\",\"time\":{\"start\":1706174853969,\"stop\":1706174853999,\"duration\":30},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"5fbdcc35f74d0d4d\",\"parentUid\":\"d8b039fe42debc8f09a74ffaf3f0d8aa\",\"status\":\"passed\",\"time\":{\"start\":1706174853956,\"stop\":1706174853961,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"caca9913474a0200\",\"parentUid\":\"d8b039fe42debc8f09a74ffaf3f0d8aa\",\"status\":\"failed\",\"time\":{\"start\":1706174854001,\"stop\":1706174854008,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res0]\",\"uid\":\"96378aa755ea26e9\",\"parentUid\":\"d8b039fe42debc8f09a74ffaf3f0d8aa\",\"status\":\"passed\",\"time\":{\"start\":1706174853945,\"stop\":1706174853953,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"4880c65bfdeaafd4\",\"parentUid\":\"d8b039fe42debc8f09a74ffaf3f0d8aa\",\"status\":\"passed\",\"time\":{\"start\":1706174854157,\"stop\":1706174854162,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]}],\"uid\":\"d8b039fe42debc8f09a74ffaf3f0d8aa\"},{\"name\":\"17092-MainThread\",\"children\":[{\"name\":\"test_login[res0]\",\"uid\":\"93128bc2f24ea57e\",\"parentUid\":\"af833a9a7dac57785a435ebaf4abd566\",\"status\":\"passed\",\"time\":{\"start\":1706175730934,\"stop\":1706175730942,\"duration\":8},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res2]\",\"uid\":\"34643e193c1bea9b\",\"parentUid\":\"af833a9a7dac57785a435ebaf4abd566\",\"status\":\"passed\",\"time\":{\"start\":1706175730977,\"stop\":1706175730982,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res2]\",\"uid\":\"c1d370af762a3c42\",\"parentUid\":\"af833a9a7dac57785a435ebaf4abd566\",\"status\":\"passed\",\"time\":{\"start\":1706175730951,\"stop\":1706175730957,\"duration\":6},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res0]\",\"uid\":\"27d27eddc3305046\",\"parentUid\":\"af833a9a7dac57785a435ebaf4abd566\",\"status\":\"passed\",\"time\":{\"start\":1706175730961,\"stop\":1706175730968,\"duration\":7},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_register[res1]\",\"uid\":\"c0c50ee6e50d4506\",\"parentUid\":\"af833a9a7dac57785a435ebaf4abd566\",\"status\":\"passed\",\"time\":{\"start\":1706175730970,\"stop\":1706175730975,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"],\"tags\":[]},{\"name\":\"test_login[res1]\",\"uid\":\"b74346d6a95334ac\",\"parentUid\":\"af833a9a7dac57785a435ebaf4abd566\",\"status\":\"passed\",\"time\":{\"start\":1706175730944,\"stop\":1706175730949,\"duration\":5},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"],\"tags\":[]}],\"uid\":\"af833a9a7dac57785a435ebaf4abd566\"},{\"name\":\"11236-MainThread\",\"children\":[{\"name\":\"test_login\",\"uid\":\"8f95947b12dc457d\",\"parentUid\":\"4bfe7b073da14e4c02805b33bdd823ae\",\"status\":\"broken\",\"time\":{\"start\":1706120407268,\"stop\":1706120407268,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]}],\"uid\":\"4bfe7b073da14e4c02805b33bdd823ae\"},{\"name\":\"9220-MainThread\",\"children\":[{\"name\":\"test_login\",\"uid\":\"99551c5f19cb7224\",\"parentUid\":\"7a1deeced74e9e2900f305ac4688090f\",\"status\":\"broken\",\"time\":{\"start\":1706118997382,\"stop\":1706118997382,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]}],\"uid\":\"7a1deeced74e9e2900f305ac4688090f\"},{\"name\":\"14312-MainThread\",\"children\":[{\"name\":\"test_login\",\"uid\":\"ac58a6a18af5deec\",\"parentUid\":\"e4eb4b4006ffc57b4a7a93efc232e144\",\"status\":\"broken\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":5,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]}],\"uid\":\"e4eb4b4006ffc57b4a7a93efc232e144\"},{\"name\":\"18480-MainThread\",\"children\":[{\"name\":\"test_login\",\"uid\":\"31d31da53575fa22\",\"parentUid\":\"fa8a2dc7c26b37912dfa25eeca8360a3\",\"status\":\"broken\",\"time\":{\"start\":1706118890830,\"stop\":1706118890830,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]}],\"uid\":\"fa8a2dc7c26b37912dfa25eeca8360a3\"},{\"name\":\"18240-MainThread\",\"children\":[{\"name\":\"test_login\",\"uid\":\"aac99276ba804081\",\"parentUid\":\"e21a5e80b4d2ed7c6daf2b65896c3632\",\"status\":\"broken\",\"time\":{\"start\":1706119375845,\"stop\":1706119375845,\"duration\":0},\"flaky\":false,\"newFailed\":false,\"newPassed\":false,\"newBroken\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"parameters\":[],\"tags\":[]}],\"uid\":\"e21a5e80b4d2ed7c6daf2b65896c3632\"}],\"uid\":\"33e802f3a7021b021af1cf3994e565b5\"}]}", 
 "data/test-cases/121364db5876c71d.json": "{\"uid\":\"121364db5876c71d\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706174692804,\"stop\":1706174692812,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3552-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"121364db5876c71d.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/12e98e1e9a8f5bbb.json": "{\"uid\":\"12e98e1e9a8f5bbb\",\"name\":\"test_register[result2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"b175c50ecbde153eef4dd01349cf1e04\",\"time\":{\"start\":1705648159530,\"stop\":1705648159538,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"12e98e1e9a8f5bbb.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/1561815528981bde.json": "{\"uid\":\"1561815528981bde\",\"name\":\"test_getsAddressList[result0]\",\"fullName\":\"testcases.test_address#test_getsAddressList\",\"historyId\":\"792ca8eb8ffd296dc312288cee8623be\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"b3ee8f0eec85491b\",\"status\":\"passed\",\"time\":{\"start\":1706176012461,\"stop\":1706176012477,\"duration\":16}},{\"uid\":\"6ebed51a52a9b14b\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024559446,\"stop\":1706024559446,\"duration\":0}},{\"uid\":\"4a630288ecb6b240\",\"status\":\"passed\",\"time\":{\"start\":1705648175265,\"stop\":1705648175287,\"duration\":22}},{\"uid\":\"b0de72f0fe71afe3\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648138299,\"stop\":1705648138299,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"1561815528981bde.json\",\"parameterValues\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/18600a6b8be8b31d.json": "{\"uid\":\"18600a6b8be8b31d\",\"name\":\"test_register[res1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"2dff4a9bee1cd78fd24b92fc336d5189\",\"time\":{\"start\":1706174957326,\"stop\":1706174957331,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"19136-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"18600a6b8be8b31d.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/19216d256fff3d6c.json": "{\"uid\":\"19216d256fff3d6c\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706176012820,\"stop\":1706176012838,\"duration\":18},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"19216d256fff3d6c.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/21370f3ffbc5706.json": "{\"uid\":\"21370f3ffbc5706\",\"name\":\"test_getDeafultAddress[result0]\",\"fullName\":\"testcases.test_address#test_getDeafultAddress\",\"historyId\":\"bd779856aa83a555802f97899913cdfc\",\"time\":{\"start\":1706024562593,\"stop\":1706024562593,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"21370f3ffbc5706.json\",\"parameterValues\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/23803f77f364625.json": "{\"uid\":\"23803f77f364625\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706174957178,\"stop\":1706174957183,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"19136-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"23803f77f364625.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/239377fefe608f69.json": "{\"uid\":\"239377fefe608f69\",\"name\":\"test_login[result2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"44c20928331d32a6a3a17265cc43f975\",\"time\":{\"start\":1705648175660,\"stop\":1705648175666,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'error-password_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"239377fefe608f69.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/24410c609482562.json": "{\"uid\":\"24410c609482562\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706174984530,\"stop\":1706174984538,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"8612-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"24410c609482562.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/2604ce0ea6dcf02e.json": "{\"uid\":\"2604ce0ea6dcf02e\",\"name\":\"test_delAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"bf300d11c33de14c99079948840baa30\",\"time\":{\"start\":1705648143415,\"stop\":1705648143415,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('009', 'fail-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"2604ce0ea6dcf02e.json\",\"parameterValues\":[\"('009', 'fail-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/27d27eddc3305046.json": "{\"uid\":\"27d27eddc3305046\",\"name\":\"test_register[res0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"82854af4d9d1f8526142efab5c28f349\",\"time\":{\"start\":1706175730961,\"stop\":1706175730968,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"17092-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"27d27eddc3305046.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/2804ffcd9a1cd236.json": "{\"uid\":\"2804ffcd9a1cd236\",\"name\":\"test_getAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d61ad735f44141ef333ff8063b084e31\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"68ccc2a7d497169c\",\"status\":\"passed\",\"time\":{\"start\":1706176012510,\"stop\":1706176012516,\"duration\":6}},{\"uid\":\"8b48dd6cfa60dcf1\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024561912,\"stop\":1706024561912,\"duration\":0}},{\"uid\":\"ca3dc772fc00a28e\",\"status\":\"passed\",\"time\":{\"start\":1705648175333,\"stop\":1705648175342,\"duration\":9}},{\"uid\":\"dc332251f910a23b\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648142847,\"stop\":1705648142847,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"2804ffcd9a1cd236.json\",\"parameterValues\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/2943596d6e1f5d.json": "{\"uid\":\"2943596d6e1f5d\",\"name\":\"test_getAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d6fdcb20142ceece4c419b7b04b54852\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"71d6c83f0b0714bf\",\"status\":\"passed\",\"time\":{\"start\":1706176012518,\"stop\":1706176012522,\"duration\":4}},{\"uid\":\"cf35e8a285e37e3c\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024562041,\"stop\":1706024562041,\"duration\":0}},{\"uid\":\"3ec5a0aca74c5be2\",\"status\":\"passed\",\"time\":{\"start\":1705648175346,\"stop\":1705648175352,\"duration\":6}},{\"uid\":\"7d6899310bfd0f72\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648142974,\"stop\":1705648142974,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"2943596d6e1f5d.json\",\"parameterValues\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/2bf22827887d5029.json": "{\"uid\":\"2bf22827887d5029\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706174984546,\"stop\":1706174984552,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"8612-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"2bf22827887d5029.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/31d31da53575fa22.json": "{\"uid\":\"31d31da53575fa22\",\"name\":\"test_login\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1473ef8c673a8ff79040e670e3f8c75e\",\"time\":{\"start\":1706118890830,\"stop\":1706118890830,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"IndexError: tuple index out of range\",\"statusTrace\":\"data_login = (('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...), ('002', 'error-username_fail', '...ser/login', 'post', ...), ('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...))\\n\\n    def test_login(data_login):\\n        print(data_login)\\n        id = data_login[0]\\n        name = data_login[1]\\n        module = data_login[2]\\n&gt;       request_prefix = data_login[3]\\nE       IndexError: tuple index out of range\\n\\ntestcases\\\\test_user.py:39: IndexError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getDBConnection\",\"time\":{\"start\":1706118890819,\"stop\":1706118890825,\"duration\":6},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"data_login\",\"time\":{\"start\":1706118890825,\"stop\":1706118890830,\"duration\":5},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getDBConnection::0\",\"time\":{\"start\":1706118890941,\"stop\":1706118890942,\"duration\":1},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"18480-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"31d31da53575fa22.json\",\"parameterValues\":[]}", 
 "data/test-cases/32b06e0816e3d789.json": "{\"uid\":\"32b06e0816e3d789\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706174692817,\"stop\":1706174692837,\"duration\":20},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3552-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"32b06e0816e3d789.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/34643e193c1bea9b.json": "{\"uid\":\"34643e193c1bea9b\",\"name\":\"test_register[res2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"534af539ac1b8b1dd523b4647fb9aad0\",\"time\":{\"start\":1706175730977,\"stop\":1706175730982,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"17092-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"34643e193c1bea9b.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/3765d8b8a8297a37.json": "{\"uid\":\"3765d8b8a8297a37\",\"name\":\"test_updateAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"5eb6b40c3fd338482b2ddfbbd0afcb56\",\"time\":{\"start\":1706024562272,\"stop\":1706024562272,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"3765d8b8a8297a37.json\",\"parameterValues\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/37e0df3b92f127b0.json": "{\"uid\":\"37e0df3b92f127b0\",\"name\":\"test_login[result1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"9d80d20fab383dd25875073860987f1d\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002356580D2D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002356580D2D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 28\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x000002356580E9B0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002356580D2D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002356580D2D0&gt;\\n_stacktrace = &lt;traceback object at 0x00000235656BF080&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_login())\\n    def test_login(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:48: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x000002356580E9B0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"a2fc69097003cf5c\",\"status\":\"passed\",\"time\":{\"start\":1705648175650,\"stop\":1705648175656,\"duration\":6}},{\"uid\":\"a4fcf360eb4a29ad\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648148480,\"stop\":1705648152538,\"duration\":4058}}],\"categories\":[{\"name\":\"Test defects\",\"matchedStatuses\":[],\"flaky\":false}],\"tags\":[]},\"source\":\"37e0df3b92f127b0.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/37e228441c4c3f65.json": "{\"uid\":\"37e228441c4c3f65\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706174785076,\"stop\":1706174785084,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"15864-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"37e228441c4c3f65.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/3e09bbfa1e0e9c33.json": "{\"uid\":\"3e09bbfa1e0e9c33\",\"name\":\"test_getDeafultAddress[result0]\",\"fullName\":\"testcases.test_address#test_getDeafultAddress\",\"historyId\":\"bd779856aa83a555802f97899913cdfc\",\"time\":{\"start\":1705648175409,\"stop\":1705648175417,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('010', 'succ-getDefaultAddress', 'address', 'localhost:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"3e09bbfa1e0e9c33.json\",\"parameterValues\":[\"('010', 'succ-getDefaultAddress', 'address', 'localhost:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/3eb22ea9f8d3f236.json": "{\"uid\":\"3eb22ea9f8d3f236\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"58417ae0310d14ae\",\"status\":\"passed\",\"time\":{\"start\":1706176012812,\"stop\":1706176012817,\"duration\":5}},{\"uid\":\"b74346d6a95334ac\",\"status\":\"passed\",\"time\":{\"start\":1706175730944,\"stop\":1706175730949,\"duration\":5}},{\"uid\":\"44cdd8ea0e91484f\",\"status\":\"passed\",\"time\":{\"start\":1706175103821,\"stop\":1706175103826,\"duration\":5}},{\"uid\":\"2bf22827887d5029\",\"status\":\"passed\",\"time\":{\"start\":1706174984546,\"stop\":1706174984552,\"duration\":6}},{\"uid\":\"23803f77f364625\",\"status\":\"passed\",\"time\":{\"start\":1706174957178,\"stop\":1706174957183,\"duration\":5}},{\"uid\":\"5fbdcc35f74d0d4d\",\"status\":\"passed\",\"time\":{\"start\":1706174853956,\"stop\":1706174853961,\"duration\":5}},{\"uid\":\"d306ab9e57f3b994\",\"status\":\"passed\",\"time\":{\"start\":1706174785086,\"stop\":1706174785092,\"duration\":6}},{\"uid\":\"121364db5876c71d\",\"status\":\"passed\",\"time\":{\"start\":1706174692804,\"stop\":1706174692812,\"duration\":8}},{\"uid\":\"5102fb4d71ab99d\",\"status\":\"broken\",\"statusDetails\":\"TypeError: tuple indices must be integers or slices, not str\",\"time\":{\"start\":1706174616539,\"stop\":1706174616539,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"3eb22ea9f8d3f236.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/3ec5a0aca74c5be2.json": "{\"uid\":\"3ec5a0aca74c5be2\",\"name\":\"test_getAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d6fdcb20142ceece4c419b7b04b54852\",\"time\":{\"start\":1705648175346,\"stop\":1705648175352,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'fail-getAddressByAid-wrongid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"3ec5a0aca74c5be2.json\",\"parameterValues\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/41358ff5883d29f4.json": "{\"uid\":\"41358ff5883d29f4\",\"name\":\"test_delAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"bf300d11c33de14c99079948840baa30\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"9ddd3edb6b9f1081\",\"status\":\"passed\",\"time\":{\"start\":1706176012558,\"stop\":1706176012584,\"duration\":26}},{\"uid\":\"847e00c0573453a3\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024562490,\"stop\":1706024562490,\"duration\":0}},{\"uid\":\"f2cad0279515ab48\",\"status\":\"passed\",\"time\":{\"start\":1705648175399,\"stop\":1705648175406,\"duration\":7}},{\"uid\":\"2604ce0ea6dcf02e\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648143415,\"stop\":1705648143415,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"41358ff5883d29f4.json\",\"parameterValues\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/41b051b435ebef16.json": "{\"uid\":\"41b051b435ebef16\",\"name\":\"test_register[result1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"4721b9645a0b1f04bafa5256b14beccb\",\"time\":{\"start\":1706024571644,\"stop\":1706024573661,\"duration\":2017},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235662E9930&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test222333'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '67', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/register', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235662E9930&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test222333'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '67', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test222333'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '67', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\ndata = b'POST /api/user/register HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encodin...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 67\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235662E9900&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235662E9930&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test222333'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '67', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/register', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/register', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235662E9930&gt;\\n_stacktrace = &lt;traceback object at 0x00000235661D7080&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_register())\\n    def test_register(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:82: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235662E9900&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"41b051b435ebef16.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/43a1ca1d96b6b40c.json": "{\"uid\":\"43a1ca1d96b6b40c\",\"name\":\"test_updateAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"a8dd1ef98d7e8e52371cbc837c6b3fc2\",\"time\":{\"start\":1706024562169,\"stop\":1706024562169,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"43a1ca1d96b6b40c.json\",\"parameterValues\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/44b23c4ed276fd3.json": "{\"uid\":\"44b23c4ed276fd3\",\"name\":\"test_order_submit[result1]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"5dd2ad784c0ec9a9715bdafce56c6124\",\"time\":{\"start\":1705648175448,\"stop\":1705648175462,\"duration\":14},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 30001 == 0\",\"statusTrace\":\"result = ('002', 'fail_order_commit', 'order', 'localhost:3000', '/api/order', 'post', ...)\\ngetToken = &lt;RequestsCookieJar[Cookie(version=0, name='koa.sid', value='JOBKtfj_FylGBbVh644B5AY_YhTqlf_i', port=None, port_specifi...ure=False, expires=1705734575, discard=False, comment=None, comment_url=None, rest={'httponly': None}, rfc2109=False)]&gt;\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_order_submit())\\n    def test_order_submit(result,getToken):\\n        cookie= getToken\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        res = Request.send_request(url, method=request_type, json=dataDict, cookies=cookie).json()\\n&gt;       assert  expect_resultDict[\\\"errno\\\"]==res[\\\"errno\\\"]\\nE       assert 30001 == 0\\n\\ntestcases\\\\test_order.py:45: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'fail_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"44b23c4ed276fd3.json\",\"parameterValues\":[\"('002', 'fail_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/44cdd8ea0e91484f.json": "{\"uid\":\"44cdd8ea0e91484f\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706175103821,\"stop\":1706175103826,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10000-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"44cdd8ea0e91484f.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/4506d4abe61d6cde.json": "{\"uid\":\"4506d4abe61d6cde\",\"name\":\"test_register[res1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"2dff4a9bee1cd78fd24b92fc336d5189\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"617a96d71a86238e\",\"status\":\"passed\",\"time\":{\"start\":1706176012848,\"stop\":1706176012853,\"duration\":5}},{\"uid\":\"c0c50ee6e50d4506\",\"status\":\"passed\",\"time\":{\"start\":1706175730970,\"stop\":1706175730975,\"duration\":5}},{\"uid\":\"e5fd9ed04dac6302\",\"status\":\"passed\",\"time\":{\"start\":1706175103964,\"stop\":1706175103970,\"duration\":6}},{\"uid\":\"c90469a05eb30fc3\",\"status\":\"passed\",\"time\":{\"start\":1706174984706,\"stop\":1706174984710,\"duration\":4}},{\"uid\":\"18600a6b8be8b31d\",\"status\":\"passed\",\"time\":{\"start\":1706174957326,\"stop\":1706174957331,\"duration\":5}},{\"uid\":\"6c14fc9a6931898e\",\"status\":\"passed\",\"time\":{\"start\":1706174854149,\"stop\":1706174854154,\"duration\":5}}],\"categories\":[],\"tags\":[]},\"source\":\"4506d4abe61d6cde.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/45b81bc67a25584.json": "{\"uid\":\"45b81bc67a25584\",\"name\":\"test_register[result1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"4721b9645a0b1f04bafa5256b14beccb\",\"time\":{\"start\":1705648159519,\"stop\":1705648159526,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'error-username_repeat_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"45b81bc67a25584.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/463a5bd2f13d8a62.json": "{\"uid\":\"463a5bd2f13d8a62\",\"name\":\"test_order_submit[result0]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"354f8fc0730a8289cdb844d5db741a9b\",\"time\":{\"start\":1705648175421,\"stop\":1705648175444,\"duration\":23},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"463a5bd2f13d8a62.json\",\"parameterValues\":[\"('001', 'succ_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/4880c65bfdeaafd4.json": "{\"uid\":\"4880c65bfdeaafd4\",\"name\":\"test_register[res2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"534af539ac1b8b1dd523b4647fb9aad0\",\"time\":{\"start\":1706174854157,\"stop\":1706174854162,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3560-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"4880c65bfdeaafd4.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/48ac857847062f9.json": "{\"uid\":\"48ac857847062f9\",\"name\":\"test_login[result2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"44c20928331d32a6a3a17265cc43f975\",\"time\":{\"start\":1705648152669,\"stop\":1705648156790,\"duration\":4121},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000001530A2D30D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000001530A2D30D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 28\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x000001530A2D3460&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000001530A2D30D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000001530A2D30D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530A3383C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('003', 'error-password_fail', 'user', 'localhost:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_login())\\n    def test_login(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:48: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x000001530A2D3460&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'error-password_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"48ac857847062f9.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/4a1618bd78fb3d9a.json": "{\"uid\":\"4a1618bd78fb3d9a\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706174984556,\"stop\":1706174984562,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"8612-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"4a1618bd78fb3d9a.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/4a630288ecb6b240.json": "{\"uid\":\"4a630288ecb6b240\",\"name\":\"test_getsAddressList[result0]\",\"fullName\":\"testcases.test_address#test_getsAddressList\",\"historyId\":\"792ca8eb8ffd296dc312288cee8623be\",\"time\":{\"start\":1705648175265,\"stop\":1705648175287,\"duration\":22},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ-getAddressList', 'address', 'localhost:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"4a630288ecb6b240.json\",\"parameterValues\":[\"('001', 'succ-getAddressList', 'address', 'localhost:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/4c56e82b4db47841.json": "{\"uid\":\"4c56e82b4db47841\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706174853969,\"stop\":1706174853999,\"duration\":30},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3560-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"4c56e82b4db47841.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/4d5227dfd64c8c2f.json": "{\"uid\":\"4d5227dfd64c8c2f\",\"name\":\"test_login[result2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"44c20928331d32a6a3a17265cc43f975\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000023566174E50&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000023566174E50&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 28\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x0000023566176AA0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000023566174E50&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000023566174E50&gt;\\n_stacktrace = &lt;traceback object at 0x00000235666C4800&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_login())\\n    def test_login(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:48: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x0000023566176AA0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"239377fefe608f69\",\"status\":\"passed\",\"time\":{\"start\":1705648175660,\"stop\":1705648175666,\"duration\":6}},{\"uid\":\"48ac857847062f9\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A2D2D70&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648152669,\"stop\":1705648156790,\"duration\":4121}}],\"categories\":[{\"name\":\"Test defects\",\"matchedStatuses\":[],\"flaky\":false}],\"tags\":[]},\"source\":\"4d5227dfd64c8c2f.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/5102fb4d71ab99d.json": "{\"uid\":\"5102fb4d71ab99d\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706174616539,\"stop\":1706174616539,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"TypeError: tuple indices must be integers or slices, not str\",\"statusTrace\":\"res = ('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"res\\\", data_login())\\n    def test_login(res):\\n&gt;       id = res['id']\\nE       TypeError: tuple indices must be integers or slices, not str\\n\\ntestcases\\\\test_user.py:30: TypeError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16972-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"5102fb4d71ab99d.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/57b26aeafef0c82.json": "{\"uid\":\"57b26aeafef0c82\",\"name\":\"test_addNewAddress[result0]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"773ff28ad212c0f08f82000af8aa6a1f\",\"time\":{\"start\":1705648142636,\"stop\":1705648142636,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'succ-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"57b26aeafef0c82.json\",\"parameterValues\":[\"('002', 'succ-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/58295da410e8d5e0.json": "{\"uid\":\"58295da410e8d5e0\",\"name\":\"test_register[res2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"534af539ac1b8b1dd523b4647fb9aad0\",\"time\":{\"start\":1706174984713,\"stop\":1706174984719,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"8612-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"58295da410e8d5e0.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/58417ae0310d14ae.json": "{\"uid\":\"58417ae0310d14ae\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706176012812,\"stop\":1706176012817,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"58417ae0310d14ae.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/58f88f2609cf025e.json": "{\"uid\":\"58f88f2609cf025e\",\"name\":\"test_login[result0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1272375df99bd519437487c4c7500a1b\",\"time\":{\"start\":1705648144134,\"stop\":1705648148235,\"duration\":4101},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000001530A01ED70&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000001530A01ED70&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x000001530A01CAC0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000001530A01ED70&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000001530A01ED70&gt;\\n_stacktrace = &lt;traceback object at 0x000001530A369840&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('001', 'succ-login', 'user', 'localhost:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_login())\\n    def test_login(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:48: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x000001530A01CAC0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ-login', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"58f88f2609cf025e.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/59aa65b9076491.json": "{\"uid\":\"59aa65b9076491\",\"name\":\"test_addNewAddress[result1]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"c8b1d81f71261fd9b020151ebd96af7e\",\"time\":{\"start\":1706024561805,\"stop\":1706024561805,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"59aa65b9076491.json\",\"parameterValues\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/5fbdcc35f74d0d4d.json": "{\"uid\":\"5fbdcc35f74d0d4d\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706174853956,\"stop\":1706174853961,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3560-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"5fbdcc35f74d0d4d.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/617a96d71a86238e.json": "{\"uid\":\"617a96d71a86238e\",\"name\":\"test_register[res1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"2dff4a9bee1cd78fd24b92fc336d5189\",\"time\":{\"start\":1706176012848,\"stop\":1706176012853,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"617a96d71a86238e.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/6240318d33740dc3.json": "{\"uid\":\"6240318d33740dc3\",\"name\":\"test_delAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"c52b47aedbefdd9435ae90087b7849b3\",\"time\":{\"start\":1705648143312,\"stop\":1705648143312,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('008', 'succ-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"6240318d33740dc3.json\",\"parameterValues\":[\"('008', 'succ-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/629bc8ce5a745b9d.json": "{\"uid\":\"629bc8ce5a745b9d\",\"name\":\"test_delAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"c52b47aedbefdd9435ae90087b7849b3\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"fe2fa76f95d27044\",\"status\":\"passed\",\"time\":{\"start\":1706176012548,\"stop\":1706176012555,\"duration\":7}},{\"uid\":\"7f25b47d29fdd0b8\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024562386,\"stop\":1706024562386,\"duration\":0}},{\"uid\":\"b7c252fb9cb31156\",\"status\":\"passed\",\"time\":{\"start\":1705648175385,\"stop\":1705648175394,\"duration\":9}},{\"uid\":\"6240318d33740dc3\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648143312,\"stop\":1705648143312,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"629bc8ce5a745b9d.json\",\"parameterValues\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/62b801e2b9af5ae6.json": "{\"uid\":\"62b801e2b9af5ae6\",\"name\":\"test_order_submit[result1]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"5dd2ad784c0ec9a9715bdafce56c6124\",\"time\":{\"start\":1706024562842,\"stop\":1706024562842,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"62b801e2b9af5ae6.json\",\"parameterValues\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/6328afffd0309615.json": "{\"uid\":\"6328afffd0309615\",\"name\":\"test_order_submit[result1]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"5dd2ad784c0ec9a9715bdafce56c6124\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 30001 == 0\",\"statusTrace\":\"result = ('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', ...)\\ngetToken = &lt;RequestsCookieJar[Cookie(version=0, name='koa.sid', value='DLDZEOfXlVrEabSDWbb1YAapHPWgJ6cy', port=None, port_specifi...ure=False, expires=1706262687, discard=False, comment=None, comment_url=None, rest={'httponly': None}, rfc2109=False)]&gt;\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_order_submit())\\n    def test_order_submit(result,getToken):\\n        cookie= getToken\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        expect_result = result[8]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        res = Request.send_request(url, method=request_type, json=dataDict, cookies=cookie).json()\\n&gt;       assert  expect_resultDict[\\\"errno\\\"]==res[\\\"errno\\\"]\\nE       assert 30001 == 0\\n\\ntestcases\\\\test_order.py:38: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"9a2a474633554637\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 30001 == 0\",\"time\":{\"start\":1706176012611,\"stop\":1706176012619,\"duration\":8}},{\"uid\":\"62b801e2b9af5ae6\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024562842,\"stop\":1706024562842,\"duration\":0}},{\"uid\":\"44b23c4ed276fd3\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 30001 == 0\",\"time\":{\"start\":1705648175448,\"stop\":1705648175462,\"duration\":14}},{\"uid\":\"829f1fa11d3b9d89\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648143809,\"stop\":1705648143809,\"duration\":0}}],\"categories\":[{\"name\":\"Product defects\",\"matchedStatuses\":[],\"flaky\":false}],\"tags\":[]},\"source\":\"6328afffd0309615.json\",\"parameterValues\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/6668ec183649f57a.json": "{\"uid\":\"6668ec183649f57a\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706174957191,\"stop\":1706174957196,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"19136-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"6668ec183649f57a.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/68ccc2a7d497169c.json": "{\"uid\":\"68ccc2a7d497169c\",\"name\":\"test_getAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d61ad735f44141ef333ff8063b084e31\",\"time\":{\"start\":1706176012510,\"stop\":1706176012516,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"68ccc2a7d497169c.json\",\"parameterValues\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/6c14fc9a6931898e.json": "{\"uid\":\"6c14fc9a6931898e\",\"name\":\"test_register[res1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"2dff4a9bee1cd78fd24b92fc336d5189\",\"time\":{\"start\":1706174854149,\"stop\":1706174854154,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3560-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"6c14fc9a6931898e.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/6ebed51a52a9b14b.json": "{\"uid\":\"6ebed51a52a9b14b\",\"name\":\"test_getsAddressList[result0]\",\"fullName\":\"testcases.test_address#test_getsAddressList\",\"historyId\":\"792ca8eb8ffd296dc312288cee8623be\",\"time\":{\"start\":1706024559446,\"stop\":1706024559446,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"6ebed51a52a9b14b.json\",\"parameterValues\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/718f6be754103361.json": "{\"uid\":\"718f6be754103361\",\"name\":\"test_order_getall[result0]\",\"fullName\":\"testcases.test_order#test_order_getall\",\"historyId\":\"6a88d5ad1d7de6f85f78d77a9eb85c7f\",\"time\":{\"start\":1706024563001,\"stop\":1706024563001,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"718f6be754103361.json\",\"parameterValues\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"]}", 
 "data/test-cases/71d6c83f0b0714bf.json": "{\"uid\":\"71d6c83f0b0714bf\",\"name\":\"test_getAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d6fdcb20142ceece4c419b7b04b54852\",\"time\":{\"start\":1706176012518,\"stop\":1706176012522,\"duration\":4},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"71d6c83f0b0714bf.json\",\"parameterValues\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/7331757ec1317ef6.json": "{\"uid\":\"7331757ec1317ef6\",\"name\":\"test_register[res2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"534af539ac1b8b1dd523b4647fb9aad0\",\"time\":{\"start\":1706176012855,\"stop\":1706176012884,\"duration\":29},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"7331757ec1317ef6.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/777ee1a42b2d201a.json": "{\"uid\":\"777ee1a42b2d201a\",\"name\":\"test_register[result0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"db808937b6c6b4b8ae95bf2b74bb3853\",\"time\":{\"start\":1705648156897,\"stop\":1705648159509,\"duration\":2612},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 0 == 1001\",\"statusTrace\":\"result = ('004', 'succ-register', 'user', 'localhost:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_register())\\n    def test_register(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n        res = Request.send_request(url, method=request_type, data=dataDict).json()\\n        # print('res==&gt;',res)\\n&gt;       assert  expect_resultDict[\\\"errno\\\"]==res[\\\"errno\\\"]\\nE       assert 0 == 1001\\n\\ntestcases\\\\test_user.py:84: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-register', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"777ee1a42b2d201a.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/7cab27e631aff5d2.json": "{\"uid\":\"7cab27e631aff5d2\",\"name\":\"test_register[result0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"db808937b6c6b4b8ae95bf2b74bb3853\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 0 == 1001\",\"statusTrace\":\"result = ('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_register())\\n    def test_register(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n        res = Request.send_request(url, method=request_type, data=dataDict).json()\\n        # print('res==&gt;',res)\\n&gt;       assert  expect_resultDict[\\\"errno\\\"]==res[\\\"errno\\\"]\\nE       assert 0 == 1001\\n\\ntestcases\\\\test_user.py:82: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"15864-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"9802d0da6fbd139f\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024569517,\"stop\":1706024571536,\"duration\":2019}},{\"uid\":\"8862ef4f323535cf\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 0 == 1001\",\"time\":{\"start\":1705648175670,\"stop\":1705648175678,\"duration\":8}},{\"uid\":\"777ee1a42b2d201a\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 0 == 1001\",\"time\":{\"start\":1705648156897,\"stop\":1705648159509,\"duration\":2612}}],\"categories\":[{\"name\":\"Product defects\",\"matchedStatuses\":[],\"flaky\":false}],\"tags\":[]},\"source\":\"7cab27e631aff5d2.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/7d2df5c839a0e516.json": "{\"uid\":\"7d2df5c839a0e516\",\"name\":\"test_register[result1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"4721b9645a0b1f04bafa5256b14beccb\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"15864-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"41b051b435ebef16\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235662E8EE0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024571644,\"stop\":1706024573661,\"duration\":2017}},{\"uid\":\"f3ddde2fc782ecd\",\"status\":\"passed\",\"time\":{\"start\":1705648175686,\"stop\":1705648175693,\"duration\":7}},{\"uid\":\"45b81bc67a25584\",\"status\":\"passed\",\"time\":{\"start\":1705648159519,\"stop\":1705648159526,\"duration\":7}}],\"categories\":[],\"tags\":[]},\"source\":\"7d2df5c839a0e516.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/7d6899310bfd0f72.json": "{\"uid\":\"7d6899310bfd0f72\",\"name\":\"test_getAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d6fdcb20142ceece4c419b7b04b54852\",\"time\":{\"start\":1705648142974,\"stop\":1705648142974,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'fail-getAddressByAid-wrongid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"7d6899310bfd0f72.json\",\"parameterValues\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/7e2d167039e5082b.json": "{\"uid\":\"7e2d167039e5082b\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706174785095,\"stop\":1706174785100,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"15864-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"7e2d167039e5082b.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/7f25b47d29fdd0b8.json": "{\"uid\":\"7f25b47d29fdd0b8\",\"name\":\"test_delAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"c52b47aedbefdd9435ae90087b7849b3\",\"time\":{\"start\":1706024562386,\"stop\":1706024562386,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"7f25b47d29fdd0b8.json\",\"parameterValues\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/823e5019b6872caf.json": "{\"uid\":\"823e5019b6872caf\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706174957169,\"stop\":1706174957176,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"19136-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"823e5019b6872caf.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/829f1fa11d3b9d89.json": "{\"uid\":\"829f1fa11d3b9d89\",\"name\":\"test_order_submit[result1]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"5dd2ad784c0ec9a9715bdafce56c6124\",\"time\":{\"start\":1705648143809,\"stop\":1705648143809,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'fail_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"829f1fa11d3b9d89.json\",\"parameterValues\":[\"('002', 'fail_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/82d31ee73066ea4d.json": "{\"uid\":\"82d31ee73066ea4d\",\"name\":\"test_updateAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"a8dd1ef98d7e8e52371cbc837c6b3fc2\",\"time\":{\"start\":1705648175357,\"stop\":1705648175370,\"duration\":13},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'succ-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"82d31ee73066ea4d.json\",\"parameterValues\":[\"('006', 'succ-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/847e00c0573453a3.json": "{\"uid\":\"847e00c0573453a3\",\"name\":\"test_delAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"bf300d11c33de14c99079948840baa30\",\"time\":{\"start\":1706024562490,\"stop\":1706024562490,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"847e00c0573453a3.json\",\"parameterValues\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/855ec7744f974935.json": "{\"uid\":\"855ec7744f974935\",\"name\":\"test_login[result0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1272375df99bd519437487c4c7500a1b\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235661CF5B0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235661CF5B0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235661CFC40&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235661CF5B0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235661CF5B0&gt;\\n_stacktrace = &lt;traceback object at 0x00000235663039C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_login())\\n    def test_login(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:48: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235661CFC40&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":2,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"eb5d88584cf2b3a5\",\"status\":\"passed\",\"time\":{\"start\":1705648175637,\"stop\":1705648175646,\"duration\":9}},{\"uid\":\"58f88f2609cf025e\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000001530A01D870&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648144134,\"stop\":1705648148235,\"duration\":4101}}],\"categories\":[{\"name\":\"Test defects\",\"matchedStatuses\":[],\"flaky\":false}],\"tags\":[]},\"source\":\"855ec7744f974935.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/86453f582e605df4.json": "{\"uid\":\"86453f582e605df4\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706176012780,\"stop\":1706176012809,\"duration\":29},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"86453f582e605df4.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/86d917d5f43504c4.json": "{\"uid\":\"86d917d5f43504c4\",\"name\":\"test_getDeafultAddress[result0]\",\"fullName\":\"testcases.test_address#test_getDeafultAddress\",\"historyId\":\"bd779856aa83a555802f97899913cdfc\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"fbd00a4f1636ad74\",\"status\":\"passed\",\"time\":{\"start\":1706176012587,\"stop\":1706176012592,\"duration\":5}},{\"uid\":\"21370f3ffbc5706\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024562593,\"stop\":1706024562593,\"duration\":0}},{\"uid\":\"3e09bbfa1e0e9c33\",\"status\":\"passed\",\"time\":{\"start\":1705648175409,\"stop\":1705648175417,\"duration\":8}},{\"uid\":\"d1e3f0d1cad9ed5\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648143538,\"stop\":1705648143538,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"86d917d5f43504c4.json\",\"parameterValues\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/8834dc40085b5894.json": "{\"uid\":\"8834dc40085b5894\",\"name\":\"test_register[res0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"82854af4d9d1f8526142efab5c28f349\",\"time\":{\"start\":1706176012840,\"stop\":1706176012846,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"8834dc40085b5894.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/8862ef4f323535cf.json": "{\"uid\":\"8862ef4f323535cf\",\"name\":\"test_register[result0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"db808937b6c6b4b8ae95bf2b74bb3853\",\"time\":{\"start\":1705648175670,\"stop\":1705648175678,\"duration\":8},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 0 == 1001\",\"statusTrace\":\"result = ('004', 'succ-register', 'user', 'localhost:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_register())\\n    def test_register(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n        res = Request.send_request(url, method=request_type, data=dataDict).json()\\n        # print('res==&gt;',res)\\n&gt;       assert  expect_resultDict[\\\"errno\\\"]==res[\\\"errno\\\"]\\nE       assert 0 == 1001\\n\\ntestcases\\\\test_user.py:84: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-register', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"8862ef4f323535cf.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/8b48dd6cfa60dcf1.json": "{\"uid\":\"8b48dd6cfa60dcf1\",\"name\":\"test_getAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d61ad735f44141ef333ff8063b084e31\",\"time\":{\"start\":1706024561912,\"stop\":1706024561912,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"8b48dd6cfa60dcf1.json\",\"parameterValues\":[\"('004', 'succ-getAddressByAid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/8c63ea0716a5841c.json": "{\"uid\":\"8c63ea0716a5841c\",\"name\":\"test_addNewAddress[result0]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"773ff28ad212c0f08f82000af8aa6a1f\",\"time\":{\"start\":1706024561700,\"stop\":1706024561700,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"8c63ea0716a5841c.json\",\"parameterValues\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/8c81b6cfd82f2126.json": "{\"uid\":\"8c81b6cfd82f2126\",\"name\":\"test_register[res0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"82854af4d9d1f8526142efab5c28f349\",\"time\":{\"start\":1706175103835,\"stop\":1706175103840,\"duration\":5},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 0 == 1001\",\"statusTrace\":\"res = ('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"res\\\", data_register())\\n    def test_register(res):\\n        id = res[0]\\n        name = res[1]\\n        module = res[2]\\n        request_prefix = res[3]\\n        request_url = res[4]\\n        request_type = res[5]\\n        need_login = res[6]\\n        data = res[7]\\n        expect_result = res[8]\\n        real_result = res[9]\\n        test_result = res[10]\\n        data_type = res[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n        resp = Request.send_request(url, method=request_type, data=dataDict).json()\\n        print('res==&gt;',res, expect_resultDict)\\n&gt;       assert expect_resultDict[\\\"errno\\\"] == resp[\\\"errno\\\"]\\nE       assert 0 == 1001\\n\\ntestcases\\\\test_user.py:82: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10000-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"8c81b6cfd82f2126.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/8f95947b12dc457d.json": "{\"uid\":\"8f95947b12dc457d\",\"name\":\"test_login\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1473ef8c673a8ff79040e670e3f8c75e\",\"time\":{\"start\":1706120407268,\"stop\":1706120407268,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"AttributeError: 'dict' object has no attribute 'id'\",\"statusTrace\":\"request = &lt;SubRequest 'data_login' for &lt;Function test_login&gt;&gt;\\ngetDBConnection = &lt;db.db.DB object at 0x000001F1E012F3D0&gt;\\n\\n    @pytest.fixture()\\n    def data_login(request,getDBConnection):\\n        db = getDBConnection\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE (id = '001' OR id = '002' OR id = '003') \\\" \\\\\\n              \\\"AND (name='succ-login' OR name='error-username_fail' OR name='error-password_fail')\\\"\\n        data = db.executeSql(SQL)\\n&gt;       request.param = [buildObj(x) for x in list(data)]\\n\\ntestcases\\\\test_user.py:43: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\ntestcases\\\\test_user.py:43: in &lt;listcomp&gt;\\n    request.param = [buildObj(x) for x in list(data)]\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\ndata = ('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...)\\n\\n    def buildObj(data):\\n        obj = {}\\n&gt;       obj.id= data[0]\\nE       AttributeError: 'dict' object has no attribute 'id'\\n\\ntestcases\\\\test_user.py:20: AttributeError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getDBConnection\",\"time\":{\"start\":1706120407269,\"stop\":1706120407273,\"duration\":4},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"data_login\",\"time\":{\"start\":1706120407274,\"stop\":1706120407274,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"AttributeError: 'dict' object has no attribute 'id'\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 908, in call_fixture_func\\n    fixture_result = fixturefunc(**kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\testcases\\\\test_user.py\\\", line 43, in data_login\\n    request.param = [buildObj(x) for x in list(data)]\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\testcases\\\\test_user.py\\\", line 43, in &lt;listcomp&gt;\\n    request.param = [buildObj(x) for x in list(data)]\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\testcases\\\\test_user.py\\\", line 20, in buildObj\\n    obj.id= data[0]\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getDBConnection::0\",\"time\":{\"start\":1706120407392,\"stop\":1706120407392,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"11236-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"8f95947b12dc457d.json\",\"parameterValues\":[]}", 
 "data/test-cases/93128bc2f24ea57e.json": "{\"uid\":\"93128bc2f24ea57e\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706175730934,\"stop\":1706175730942,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"17092-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"93128bc2f24ea57e.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/93dbb0360b0f1050.json": "{\"uid\":\"93dbb0360b0f1050\",\"name\":\"test_updateAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"a8dd1ef98d7e8e52371cbc837c6b3fc2\",\"time\":{\"start\":1706176012525,\"stop\":1706176012534,\"duration\":9},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"93dbb0360b0f1050.json\",\"parameterValues\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/96378aa755ea26e9.json": "{\"uid\":\"96378aa755ea26e9\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706174853945,\"stop\":1706174853953,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3560-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"96378aa755ea26e9.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/9802d0da6fbd139f.json": "{\"uid\":\"9802d0da6fbd139f\",\"name\":\"test_register[result0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"db808937b6c6b4b8ae95bf2b74bb3853\",\"time\":{\"start\":1706024569517,\"stop\":1706024571536,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002356620FBB0&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test222333'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '67', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/register', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002356620FBB0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test222333'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '67', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test222333'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '67', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\ndata = b'POST /api/user/register HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encodin...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 67\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x000002356620D4B0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002356620FBB0&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test222333'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '67', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/register', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/register', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x000002356620FBB0&gt;\\n_stacktrace = &lt;traceback object at 0x00000235666F8BC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_register())\\n    def test_register(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:82: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x000002356620D4B0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356620F730&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"9802d0da6fbd139f.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/992369678935f076.json": "{\"uid\":\"992369678935f076\",\"name\":\"test_updateAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"5eb6b40c3fd338482b2ddfbbd0afcb56\",\"time\":{\"start\":1705648175373,\"stop\":1705648175380,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('007', 'fail-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"992369678935f076.json\",\"parameterValues\":[\"('007', 'fail-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/99551c5f19cb7224.json": "{\"uid\":\"99551c5f19cb7224\",\"name\":\"test_login\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1473ef8c673a8ff79040e670e3f8c75e\",\"time\":{\"start\":1706118997382,\"stop\":1706118997382,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"IndexError: tuple index out of range\",\"statusTrace\":\"data_login = (('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...), ('002', 'error-username_fail', '...ser/login', 'post', ...), ('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...))\\n\\n    def test_login(data_login):\\n        for i in data_login:\\n            print('ii===&gt;', i)\\n        id = data_login[0]\\n        name = data_login[1]\\n        module = data_login[2]\\n&gt;       request_prefix = data_login[3]\\nE       IndexError: tuple index out of range\\n\\ntestcases\\\\test_user.py:40: IndexError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getDBConnection\",\"time\":{\"start\":1706118997376,\"stop\":1706118997380,\"duration\":4},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"data_login\",\"time\":{\"start\":1706118997380,\"stop\":1706118997381,\"duration\":1},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getDBConnection::0\",\"time\":{\"start\":1706118997497,\"stop\":1706118997497,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9220-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"99551c5f19cb7224.json\",\"parameterValues\":[]}", 
 "data/test-cases/9983dff8d8f5cc9e.json": "{\"uid\":\"9983dff8d8f5cc9e\",\"name\":\"test_register[result2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"b175c50ecbde153eef4dd01349cf1e04\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":3,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"15864-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"bbe95b736bb987cd\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024573800,\"stop\":1706024575816,\"duration\":2016}},{\"uid\":\"f310db1fc79fd9d5\",\"status\":\"passed\",\"time\":{\"start\":1705648175697,\"stop\":1705648175704,\"duration\":7}},{\"uid\":\"12e98e1e9a8f5bbb\",\"status\":\"passed\",\"time\":{\"start\":1705648159530,\"stop\":1705648159538,\"duration\":8}}],\"categories\":[],\"tags\":[]},\"source\":\"9983dff8d8f5cc9e.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/9a2a474633554637.json": "{\"uid\":\"9a2a474633554637\",\"name\":\"test_order_submit[result1]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"5dd2ad784c0ec9a9715bdafce56c6124\",\"time\":{\"start\":1706176012611,\"stop\":1706176012619,\"duration\":8},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 30001 == 0\",\"statusTrace\":\"result = ('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', ...)\\ngetToken = &lt;RequestsCookieJar[Cookie(version=0, name='koa.sid', value='zqgaf00BDG_SABxwNfDQ7QhQ1gbyiICk', port=None, port_specifi...ure=False, expires=1706262412, discard=False, comment=None, comment_url=None, rest={'httponly': None}, rfc2109=False)]&gt;\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_order_submit())\\n    def test_order_submit(result,getToken):\\n        cookie= getToken\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        res = Request.send_request(url, method=request_type, json=dataDict, cookies=cookie).json()\\n&gt;       assert  expect_resultDict[\\\"errno\\\"]==res[\\\"errno\\\"]\\nE       assert 30001 == 0\\n\\ntestcases\\\\test_order.py:45: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"9a2a474633554637.json\",\"parameterValues\":[\"('002', 'fail_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', 'null', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', '{\\\"errno\\\":30001, \\\"message\\\":\\\"创建订单出错\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/9b47a930887b90e6.json": "{\"uid\":\"9b47a930887b90e6\",\"name\":\"test_updateAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"5eb6b40c3fd338482b2ddfbbd0afcb56\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"bef61f13e3947915\",\"status\":\"passed\",\"time\":{\"start\":1706176012537,\"stop\":1706176012544,\"duration\":7}},{\"uid\":\"3765d8b8a8297a37\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024562272,\"stop\":1706024562272,\"duration\":0}},{\"uid\":\"992369678935f076\",\"status\":\"passed\",\"time\":{\"start\":1705648175373,\"stop\":1705648175380,\"duration\":7}},{\"uid\":\"c5eb365d82d86cd5\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648143194,\"stop\":1705648143194,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"9b47a930887b90e6.json\",\"parameterValues\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/9ddd3edb6b9f1081.json": "{\"uid\":\"9ddd3edb6b9f1081\",\"name\":\"test_delAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"bf300d11c33de14c99079948840baa30\",\"time\":{\"start\":1706176012558,\"stop\":1706176012584,\"duration\":26},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"9ddd3edb6b9f1081.json\",\"parameterValues\":[\"('009', 'fail-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/a2fc69097003cf5c.json": "{\"uid\":\"a2fc69097003cf5c\",\"name\":\"test_login[result1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"9d80d20fab383dd25875073860987f1d\",\"time\":{\"start\":1705648175650,\"stop\":1705648175656,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'error-username_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"a2fc69097003cf5c.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/a42e21610ad5fe5b.json": "{\"uid\":\"a42e21610ad5fe5b\",\"name\":\"test_register[res0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"82854af4d9d1f8526142efab5c28f349\",\"time\":{\"start\":1706174957199,\"stop\":1706174957205,\"duration\":6},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 0 == 1001\",\"statusTrace\":\"res = ('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"res\\\", data_register())\\n    def test_register(res):\\n        id = res[0]\\n        name = res[1]\\n        module = res[2]\\n        request_prefix = res[3]\\n        request_url = res[4]\\n        request_type = res[5]\\n        need_login = res[6]\\n        data = res[7]\\n        expect_result = res[8]\\n        real_result = res[9]\\n        test_result = res[10]\\n        data_type = res[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n        resp = Request.send_request(url, method=request_type, data=dataDict).json()\\n        # print('res==&gt;',res)\\n&gt;       assert expect_resultDict[\\\"errno\\\"] == resp[\\\"errno\\\"]\\nE       assert 0 == 1001\\n\\ntestcases\\\\test_user.py:82: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"19136-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"a42e21610ad5fe5b.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/a4fcf360eb4a29ad.json": "{\"uid\":\"a4fcf360eb4a29ad\",\"name\":\"test_login[result1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"9d80d20fab383dd25875073860987f1d\",\"time\":{\"start\":1705648148480,\"stop\":1705648152538,\"duration\":4058},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000015309F88730&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000015309F88730&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 28\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x0000015309F8B8E0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000015309F88730&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '28', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000015309F88730&gt;\\n_stacktrace = &lt;traceback object at 0x000001530A3AE440&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('002', 'error-username_fail', 'user', 'localhost:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_login())\\n    def test_login(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:48: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x0000015309F8B8E0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309F89D50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'error-username_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"a4fcf360eb4a29ad.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/a564f466e85d11d2.json": "{\"uid\":\"a564f466e85d11d2\",\"name\":\"test_order_submit[result0]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"354f8fc0730a8289cdb844d5db741a9b\",\"time\":{\"start\":1706176012595,\"stop\":1706176012609,\"duration\":14},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"a564f466e85d11d2.json\",\"parameterValues\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/a605a95d5e451326.json": "{\"uid\":\"a605a95d5e451326\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706175103828,\"stop\":1706175103833,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10000-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"a605a95d5e451326.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/a726103007684711.json": "{\"uid\":\"a726103007684711\",\"name\":\"test_addNewAddress[result1]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"c8b1d81f71261fd9b020151ebd96af7e\",\"time\":{\"start\":1706176012497,\"stop\":1706176012508,\"duration\":11},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"a726103007684711.json\",\"parameterValues\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/aac99276ba804081.json": "{\"uid\":\"aac99276ba804081\",\"name\":\"test_login\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1473ef8c673a8ff79040e670e3f8c75e\",\"time\":{\"start\":1706119375845,\"stop\":1706119375845,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"IndexError: list index out of range\",\"statusTrace\":\"data_login = [('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...), ('002', 'error-username_fail', '...ser/login', 'post', ...), ('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...)]\\n\\n    def test_login(data_login):\\n        for i in data_login:\\n            print('ii===&gt;', i)\\n        id = data_login[0]\\n        name = data_login[1]\\n        module = data_login[2]\\n&gt;       request_prefix = data_login[3]\\nE       IndexError: list index out of range\\n\\ntestcases\\\\test_user.py:40: IndexError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getDBConnection\",\"time\":{\"start\":1706119375839,\"stop\":1706119375843,\"duration\":4},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"data_login\",\"time\":{\"start\":1706119375843,\"stop\":1706119375844,\"duration\":1},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getDBConnection::0\",\"time\":{\"start\":1706119375955,\"stop\":1706119375955,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"18240-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"aac99276ba804081.json\",\"parameterValues\":[]}", 
 "data/test-cases/ab68508ce08448.json": "{\"uid\":\"ab68508ce08448\",\"name\":\"test_register[res0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"82854af4d9d1f8526142efab5c28f349\",\"time\":{\"start\":1706174984567,\"stop\":1706174984575,\"duration\":8},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 0 == 1001\",\"statusTrace\":\"res = ('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"res\\\", data_register())\\n    def test_register(res):\\n        id = res[0]\\n        name = res[1]\\n        module = res[2]\\n        request_prefix = res[3]\\n        request_url = res[4]\\n        request_type = res[5]\\n        need_login = res[6]\\n        data = res[7]\\n        expect_result = res[8]\\n        real_result = res[9]\\n        test_result = res[10]\\n        data_type = res[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n        resp = Request.send_request(url, method=request_type, data=dataDict).json()\\n        print('res==&gt;',res)\\n&gt;       assert expect_resultDict[\\\"errno\\\"] == resp[\\\"errno\\\"]\\nE       assert 0 == 1001\\n\\ntestcases\\\\test_user.py:82: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"8612-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"ab68508ce08448.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/ac58a6a18af5deec.json": "{\"uid\":\"ac58a6a18af5deec\",\"name\":\"test_login\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1473ef8c673a8ff79040e670e3f8c75e\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"TypeError: list indices must be integers or slices, not str\",\"statusTrace\":\"data_login = [{'data': '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', 'data_type': 'miss', 'expect_result': '{\\\"errno\\\":0,\\\"data\\\":null,\\\"me...test3\\\",\\\"password\\\":\\\"test\\\"}', 'data_type': 'miss', 'expect_result': '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', 'id': '003', ...}]\\n\\n    def test_login(data_login):\\n        for i in data_login:\\n            print('ii===&gt;', i)\\n&gt;       id = data_login['id']\\nE       TypeError: list indices must be integers or slices, not str\\n\\ntestcases\\\\test_user.py:51: TypeError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":5,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getDBConnection\",\"time\":{\"start\":1706120658288,\"stop\":1706120658302,\"duration\":14},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"data_login\",\"time\":{\"start\":1706120658302,\"stop\":1706120658303,\"duration\":1},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getDBConnection::0\",\"time\":{\"start\":1706120658417,\"stop\":1706120658417,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"14312-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"8f95947b12dc457d\",\"status\":\"broken\",\"statusDetails\":\"AttributeError: 'dict' object has no attribute 'id'\",\"time\":{\"start\":1706120407268,\"stop\":1706120407268,\"duration\":0}},{\"uid\":\"faf5ca61d101cd27\",\"status\":\"broken\",\"statusDetails\":\"TypeError: 'list' object cannot be interpreted as an integer\",\"time\":{\"start\":1706120368292,\"stop\":1706120368292,\"duration\":0}},{\"uid\":\"aac99276ba804081\",\"status\":\"broken\",\"statusDetails\":\"IndexError: list index out of range\",\"time\":{\"start\":1706119375845,\"stop\":1706119375845,\"duration\":0}},{\"uid\":\"99551c5f19cb7224\",\"status\":\"broken\",\"statusDetails\":\"IndexError: tuple index out of range\",\"time\":{\"start\":1706118997382,\"stop\":1706118997382,\"duration\":0}},{\"uid\":\"31d31da53575fa22\",\"status\":\"broken\",\"statusDetails\":\"IndexError: tuple index out of range\",\"time\":{\"start\":1706118890830,\"stop\":1706118890830,\"duration\":0}}],\"categories\":[{\"name\":\"Test defects\",\"matchedStatuses\":[],\"flaky\":false}],\"tags\":[]},\"source\":\"ac58a6a18af5deec.json\",\"parameterValues\":[]}", 
 "data/test-cases/b0de72f0fe71afe3.json": "{\"uid\":\"b0de72f0fe71afe3\",\"name\":\"test_getsAddressList[result0]\",\"fullName\":\"testcases.test_address#test_getsAddressList\",\"historyId\":\"792ca8eb8ffd296dc312288cee8623be\",\"time\":{\"start\":1705648138299,\"stop\":1705648138299,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ-getAddressList', 'address', 'localhost:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"b0de72f0fe71afe3.json\",\"parameterValues\":[\"('001', 'succ-getAddressList', 'address', 'localhost:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/b3ee8f0eec85491b.json": "{\"uid\":\"b3ee8f0eec85491b\",\"name\":\"test_getsAddressList[result0]\",\"fullName\":\"testcases.test_address#test_getsAddressList\",\"historyId\":\"792ca8eb8ffd296dc312288cee8623be\",\"time\":{\"start\":1706176012461,\"stop\":1706176012477,\"duration\":16},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"b3ee8f0eec85491b.json\",\"parameterValues\":[\"('001', 'succ-getAddressList', 'address', '192.168.0.105:3000', '/api/user/address', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": [],\\\\r\\\\n  \\\"message\\\": \\\"获取全部地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/b74346d6a95334ac.json": "{\"uid\":\"b74346d6a95334ac\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706175730944,\"stop\":1706175730949,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"17092-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"b74346d6a95334ac.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/b7c252fb9cb31156.json": "{\"uid\":\"b7c252fb9cb31156\",\"name\":\"test_delAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"c52b47aedbefdd9435ae90087b7849b3\",\"time\":{\"start\":1705648175385,\"stop\":1705648175394,\"duration\":9},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('008', 'succ-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"b7c252fb9cb31156.json\",\"parameterValues\":[\"('008', 'succ-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/b8627919718d53a8.json": "{\"uid\":\"b8627919718d53a8\",\"name\":\"test_order_getall[result0]\",\"fullName\":\"testcases.test_order#test_order_getall\",\"historyId\":\"6a88d5ad1d7de6f85f78d77a9eb85c7f\",\"time\":{\"start\":1705648144000,\"stop\":1705648144000,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'succ_order_getAll', 'order', 'localhost:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"b8627919718d53a8.json\",\"parameterValues\":[\"('003', 'succ_order_getAll', 'order', 'localhost:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"]}", 
 "data/test-cases/bbe95b736bb987cd.json": "{\"uid\":\"bbe95b736bb987cd\",\"name\":\"test_register[result2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"b175c50ecbde153eef4dd01349cf1e04\",\"time\":{\"start\":1706024573800,\"stop\":1706024575816,\"duration\":2016},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000023566148400&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test22233'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '66', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/register', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000023566148400&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test22233'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '66', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test22233'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '66', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\ndata = b'POST /api/user/register HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encodin...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 66\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235661495D0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000023566148400&gt;\\nmethod = 'POST', url = '/api/user/register'\\nbody = 'username=test222333&password=test222333&confirm_password=test22233'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '66', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/register', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/register', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x0000023566148400&gt;\\n_stacktrace = &lt;traceback object at 0x00000235666B2600&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\nresult = ('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_register())\\n    def test_register(result):\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict).json()\\n\\ntestcases\\\\test_user.py:82: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235661495D0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/register (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566148040&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"bbe95b736bb987cd.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/bc1d41551a77e65e.json": "{\"uid\":\"bc1d41551a77e65e\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706174616413,\"stop\":1706174616413,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"TypeError: tuple indices must be integers or slices, not str\",\"statusTrace\":\"res = ('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"res\\\", data_login())\\n    def test_login(res):\\n&gt;       id = res['id']\\nE       TypeError: tuple indices must be integers or slices, not str\\n\\ntestcases\\\\test_user.py:30: TypeError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16972-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"bc1d41551a77e65e.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/bee54566c8d789a1.json": "{\"uid\":\"bee54566c8d789a1\",\"name\":\"test_register[res2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"534af539ac1b8b1dd523b4647fb9aad0\",\"time\":{\"start\":1706174957334,\"stop\":1706174957339,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"19136-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"bee54566c8d789a1.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/bef61f13e3947915.json": "{\"uid\":\"bef61f13e3947915\",\"name\":\"test_updateAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"5eb6b40c3fd338482b2ddfbbd0afcb56\",\"time\":{\"start\":1706176012537,\"stop\":1706176012544,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"bef61f13e3947915.json\",\"parameterValues\":[\"('007', 'fail-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/bfe4fb7ad9acbe71.json": "{\"uid\":\"bfe4fb7ad9acbe71\",\"name\":\"test_addNewAddress[result0]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"773ff28ad212c0f08f82000af8aa6a1f\",\"time\":{\"start\":1705648175291,\"stop\":1705648175315,\"duration\":24},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'succ-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"bfe4fb7ad9acbe71.json\",\"parameterValues\":[\"('002', 'succ-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/c02bfde9815c6999.json": "{\"uid\":\"c02bfde9815c6999\",\"name\":\"test_addNewAddress[result1]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"c8b1d81f71261fd9b020151ebd96af7e\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"a726103007684711\",\"status\":\"passed\",\"time\":{\"start\":1706176012497,\"stop\":1706176012508,\"duration\":11}},{\"uid\":\"59aa65b9076491\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024561805,\"stop\":1706024561805,\"duration\":0}},{\"uid\":\"c646cb618c139539\",\"status\":\"passed\",\"time\":{\"start\":1705648175318,\"stop\":1705648175330,\"duration\":12}},{\"uid\":\"fdbdaea3ad155ee1\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648142740,\"stop\":1705648142740,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"c02bfde9815c6999.json\",\"parameterValues\":[\"('003', 'fail-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/c0c50ee6e50d4506.json": "{\"uid\":\"c0c50ee6e50d4506\",\"name\":\"test_register[res1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"2dff4a9bee1cd78fd24b92fc336d5189\",\"time\":{\"start\":1706175730970,\"stop\":1706175730975,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"17092-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"c0c50ee6e50d4506.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/c1ab83aa5974a5fe.json": "{\"uid\":\"c1ab83aa5974a5fe\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"86453f582e605df4\",\"status\":\"passed\",\"time\":{\"start\":1706176012780,\"stop\":1706176012809,\"duration\":29}},{\"uid\":\"93128bc2f24ea57e\",\"status\":\"passed\",\"time\":{\"start\":1706175730934,\"stop\":1706175730942,\"duration\":8}},{\"uid\":\"d5f5676e825a95df\",\"status\":\"passed\",\"time\":{\"start\":1706175103811,\"stop\":1706175103818,\"duration\":7}},{\"uid\":\"24410c609482562\",\"status\":\"passed\",\"time\":{\"start\":1706174984530,\"stop\":1706174984538,\"duration\":8}},{\"uid\":\"823e5019b6872caf\",\"status\":\"passed\",\"time\":{\"start\":1706174957169,\"stop\":1706174957176,\"duration\":7}},{\"uid\":\"96378aa755ea26e9\",\"status\":\"passed\",\"time\":{\"start\":1706174853945,\"stop\":1706174853953,\"duration\":8}},{\"uid\":\"37e228441c4c3f65\",\"status\":\"passed\",\"time\":{\"start\":1706174785076,\"stop\":1706174785084,\"duration\":8}},{\"uid\":\"d5b7145fa232099c\",\"status\":\"passed\",\"time\":{\"start\":1706174692737,\"stop\":1706174692800,\"duration\":63}},{\"uid\":\"bc1d41551a77e65e\",\"status\":\"broken\",\"statusDetails\":\"TypeError: tuple indices must be integers or slices, not str\",\"time\":{\"start\":1706174616413,\"stop\":1706174616413,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"c1ab83aa5974a5fe.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/c1d370af762a3c42.json": "{\"uid\":\"c1d370af762a3c42\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706175730951,\"stop\":1706175730957,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"17092-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"c1d370af762a3c42.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/c5eb365d82d86cd5.json": "{\"uid\":\"c5eb365d82d86cd5\",\"name\":\"test_updateAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"5eb6b40c3fd338482b2ddfbbd0afcb56\",\"time\":{\"start\":1705648143194,\"stop\":1705648143194,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('007', 'fail-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"c5eb365d82d86cd5.json\",\"parameterValues\":[\"('007', 'fail-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20022,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/c646cb618c139539.json": "{\"uid\":\"c646cb618c139539\",\"name\":\"test_addNewAddress[result1]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"c8b1d81f71261fd9b020151ebd96af7e\",\"time\":{\"start\":1705648175318,\"stop\":1705648175330,\"duration\":12},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'fail-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"c646cb618c139539.json\",\"parameterValues\":[\"('003', 'fail-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/c90469a05eb30fc3.json": "{\"uid\":\"c90469a05eb30fc3\",\"name\":\"test_register[res1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"2dff4a9bee1cd78fd24b92fc336d5189\",\"time\":{\"start\":1706174984706,\"stop\":1706174984710,\"duration\":4},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"8612-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"c90469a05eb30fc3.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/ca3dc772fc00a28e.json": "{\"uid\":\"ca3dc772fc00a28e\",\"name\":\"test_getAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d61ad735f44141ef333ff8063b084e31\",\"time\":{\"start\":1705648175333,\"stop\":1705648175342,\"duration\":9},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-getAddressByAid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"ca3dc772fc00a28e.json\",\"parameterValues\":[\"('004', 'succ-getAddressByAid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/caca9913474a0200.json": "{\"uid\":\"caca9913474a0200\",\"name\":\"test_register[res0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"82854af4d9d1f8526142efab5c28f349\",\"time\":{\"start\":1706174854001,\"stop\":1706174854008,\"duration\":7},\"status\":\"failed\",\"statusMessage\":\"AssertionError: assert 0 == 1001\",\"statusTrace\":\"res = {'errno': 1001, 'message': '注册失败'}\\n\\n    @pytest.mark.parametrize(\\\"res\\\", data_register())\\n    def test_register(res):\\n        id = res[0]\\n        name = res[1]\\n        module = res[2]\\n        request_prefix = res[3]\\n        request_url = res[4]\\n        request_type = res[5]\\n        need_login = res[6]\\n        data = res[7]\\n        expect_result = res[8]\\n        real_result = res[9]\\n        test_result = res[10]\\n        data_type = res[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        # print( url, dataDict, type(dataDict),expect_resultDict, type(expect_resultDict))\\n        res = Request.send_request(url, method=request_type, data=dataDict).json()\\n        # print('res==&gt;',res)\\n&gt;       assert expect_resultDict[\\\"errno\\\"] == res[\\\"errno\\\"]\\nE       assert 0 == 1001\\n\\ntestcases\\\\test_user.py:82: AssertionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3560-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"caca9913474a0200.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/cf35e8a285e37e3c.json": "{\"uid\":\"cf35e8a285e37e3c\",\"name\":\"test_getAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d6fdcb20142ceece4c419b7b04b54852\",\"time\":{\"start\":1706024562041,\"stop\":1706024562041,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"cf35e8a285e37e3c.json\",\"parameterValues\":[\"('005', 'fail-getAddressByAid-wrongid', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20024,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/d105b1c5083274ac.json": "{\"uid\":\"d105b1c5083274ac\",\"name\":\"test_register[res2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"534af539ac1b8b1dd523b4647fb9aad0\",\"time\":{\"start\":1706175103974,\"stop\":1706175103979,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10000-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"d105b1c5083274ac.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/d1e3f0d1cad9ed5.json": "{\"uid\":\"d1e3f0d1cad9ed5\",\"name\":\"test_getDeafultAddress[result0]\",\"fullName\":\"testcases.test_address#test_getDeafultAddress\",\"historyId\":\"bd779856aa83a555802f97899913cdfc\",\"time\":{\"start\":1705648143538,\"stop\":1705648143538,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('010', 'succ-getDefaultAddress', 'address', 'localhost:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"d1e3f0d1cad9ed5.json\",\"parameterValues\":[\"('010', 'succ-getDefaultAddress', 'address', 'localhost:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/d306ab9e57f3b994.json": "{\"uid\":\"d306ab9e57f3b994\",\"name\":\"test_login[res1]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"530e96ce51840b43ba9ed6286de20d0f\",\"time\":{\"start\":1706174785086,\"stop\":1706174785092,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"15864-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"d306ab9e57f3b994.json\",\"parameterValues\":[\"('002', 'error-username_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/d488b61a1a8655ff.json": "{\"uid\":\"d488b61a1a8655ff\",\"name\":\"test_register[res2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"534af539ac1b8b1dd523b4647fb9aad0\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":6,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"7331757ec1317ef6\",\"status\":\"passed\",\"time\":{\"start\":1706176012855,\"stop\":1706176012884,\"duration\":29}},{\"uid\":\"34643e193c1bea9b\",\"status\":\"passed\",\"time\":{\"start\":1706175730977,\"stop\":1706175730982,\"duration\":5}},{\"uid\":\"d105b1c5083274ac\",\"status\":\"passed\",\"time\":{\"start\":1706175103974,\"stop\":1706175103979,\"duration\":5}},{\"uid\":\"58295da410e8d5e0\",\"status\":\"passed\",\"time\":{\"start\":1706174984713,\"stop\":1706174984719,\"duration\":6}},{\"uid\":\"bee54566c8d789a1\",\"status\":\"passed\",\"time\":{\"start\":1706174957334,\"stop\":1706174957339,\"duration\":5}},{\"uid\":\"4880c65bfdeaafd4\",\"status\":\"passed\",\"time\":{\"start\":1706174854157,\"stop\":1706174854162,\"duration\":5}}],\"categories\":[],\"tags\":[]},\"source\":\"d488b61a1a8655ff.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/d53f6d70a9c81d71.json": "{\"uid\":\"d53f6d70a9c81d71\",\"name\":\"test_order_submit[result0]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"354f8fc0730a8289cdb844d5db741a9b\",\"time\":{\"start\":1706024562709,\"stop\":1706024562709,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('192.168.0.105', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: 192.168.0.105:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: ...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000235656B9510&gt;\\n_stacktrace = &lt;traceback object at 0x00000235639594C0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000235656B9300&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706024559448,\"stop\":1706024561467,\"duration\":2019},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"9944-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"d53f6d70a9c81d71.json\",\"parameterValues\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/d5a5b2c179710c79.json": "{\"uid\":\"d5a5b2c179710c79\",\"name\":\"test_addNewAddress[result0]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"773ff28ad212c0f08f82000af8aa6a1f\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"deccf557b865d595\",\"status\":\"passed\",\"time\":{\"start\":1706176012480,\"stop\":1706176012494,\"duration\":14}},{\"uid\":\"8c63ea0716a5841c\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024561700,\"stop\":1706024561700,\"duration\":0}},{\"uid\":\"bfe4fb7ad9acbe71\",\"status\":\"passed\",\"time\":{\"start\":1705648175291,\"stop\":1705648175315,\"duration\":24}},{\"uid\":\"57b26aeafef0c82\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648142636,\"stop\":1705648142636,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"d5a5b2c179710c79.json\",\"parameterValues\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/d5b7145fa232099c.json": "{\"uid\":\"d5b7145fa232099c\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706174692737,\"stop\":1706174692800,\"duration\":63},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"3552-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"d5b7145fa232099c.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/d5f5676e825a95df.json": "{\"uid\":\"d5f5676e825a95df\",\"name\":\"test_login[res0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"62a591e4bed58feff41f2aa0646771b2\",\"time\":{\"start\":1706175103811,\"stop\":1706175103818,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10000-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"d5f5676e825a95df.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/db71788f163efb6b.json": "{\"uid\":\"db71788f163efb6b\",\"name\":\"test_updateAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"a8dd1ef98d7e8e52371cbc837c6b3fc2\",\"time\":{\"start\":1705648143087,\"stop\":1705648143087,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'succ-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"db71788f163efb6b.json\",\"parameterValues\":[\"('006', 'succ-updateAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/dc332251f910a23b.json": "{\"uid\":\"dc332251f910a23b\",\"name\":\"test_getAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_getAddressByAid\",\"historyId\":\"d61ad735f44141ef333ff8063b084e31\",\"time\":{\"start\":1705648142847,\"stop\":1705648142847,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('004', 'succ-getAddressByAid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"dc332251f910a23b.json\",\"parameterValues\":[\"('004', 'succ-getAddressByAid', 'address', 'localhost:3000', '/api/user/address/aid/', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回单个地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/dde8b1bbd7520535.json": "{\"uid\":\"dde8b1bbd7520535\",\"name\":\"test_order_getall[result0]\",\"fullName\":\"testcases.test_order#test_order_getall\",\"historyId\":\"6a88d5ad1d7de6f85f78d77a9eb85c7f\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"f41f8f3868551db9\",\"status\":\"broken\",\"statusDetails\":\"KeyError: 'message'\",\"time\":{\"start\":1706176012732,\"stop\":1706176012773,\"duration\":41}},{\"uid\":\"718f6be754103361\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024563001,\"stop\":1706024563001,\"duration\":0}},{\"uid\":\"ebd5a39f8564059c\",\"status\":\"broken\",\"statusDetails\":\"KeyError: 'message'\",\"time\":{\"start\":1705648175590,\"stop\":1705648175627,\"duration\":37}},{\"uid\":\"b8627919718d53a8\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648144000,\"stop\":1705648144000,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"dde8b1bbd7520535.json\",\"parameterValues\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"]}", 
 "data/test-cases/deccf557b865d595.json": "{\"uid\":\"deccf557b865d595\",\"name\":\"test_addNewAddress[result0]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"773ff28ad212c0f08f82000af8aa6a1f\",\"time\":{\"start\":1706176012480,\"stop\":1706176012494,\"duration\":14},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"deccf557b865d595.json\",\"parameterValues\":[\"('002', 'succ-addNewAddress', 'address', '192.168.0.105:3000', '/api/user/address', 'post', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214830\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"创建地址成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/e4749b9164c6442c.json": "{\"uid\":\"e4749b9164c6442c\",\"name\":\"test_updateAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_updateAddressByAid\",\"historyId\":\"a8dd1ef98d7e8e52371cbc837c6b3fc2\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176287686,\"stop\":1706176287686,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"93dbb0360b0f1050\",\"status\":\"passed\",\"time\":{\"start\":1706176012525,\"stop\":1706176012534,\"duration\":9}},{\"uid\":\"43a1ca1d96b6b40c\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024562169,\"stop\":1706024562169,\"duration\":0}},{\"uid\":\"82d31ee73066ea4d\",\"status\":\"passed\",\"time\":{\"start\":1705648175357,\"stop\":1705648175370,\"duration\":13}},{\"uid\":\"db71788f163efb6b\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648143087,\"stop\":1705648143087,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"e4749b9164c6442c.json\",\"parameterValues\":[\"('006', 'succ-updateAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'patch', '1', '{\\\\r\\\\n  \\\"recevierName\\\": \\\"收货人名字更新测试\\\",\\\\r\\\\n  \\\"phoneNumber\\\": \\\"13632214831\\\",\\\\r\\\\n  \\\"city\\\": \\\"石家庄市\\\",\\\\r\\\\n  \\\"county\\\": \\\"长安区\\\",\\\\r\\\\n  \\\"province\\\": \\\"河北省\\\",\\\\r\\\\n  \\\"areaCode\\\": \\\"130102\\\",\\\\r\\\\n  \\\"addressDetail\\\": \\\"具体地址测试更新\\\",\\\\r\\\\n  \\\"isDefault\\\": \\\"false\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"更新成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/e48f4a8ea6ffe578.json": "{\"uid\":\"e48f4a8ea6ffe578\",\"name\":\"test_order_submit[result0]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"354f8fc0730a8289cdb844d5db741a9b\",\"time\":{\"start\":1705648143659,\"stop\":1705648143659,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"e48f4a8ea6ffe578.json\",\"parameterValues\":[\"('001', 'succ_order_commit', 'order', 'localhost:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/e5fd9ed04dac6302.json": "{\"uid\":\"e5fd9ed04dac6302\",\"name\":\"test_register[res1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"2dff4a9bee1cd78fd24b92fc336d5189\",\"time\":{\"start\":1706175103964,\"stop\":1706175103970,\"duration\":6},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10000-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"e5fd9ed04dac6302.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/eb5d88584cf2b3a5.json": "{\"uid\":\"eb5d88584cf2b3a5\",\"name\":\"test_login[result0]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1272375df99bd519437487c4c7500a1b\",\"time\":{\"start\":1705648175637,\"stop\":1705648175646,\"duration\":9},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ-login', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"eb5d88584cf2b3a5.json\",\"parameterValues\":[\"('001', 'succ-login', 'user', 'localhost:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test3\\\"}', '{\\\"errno\\\":0,\\\"data\\\":null,\\\"message\\\":\\\"登录成功\\\"}', '{\\\\n  \\\"errno\\\": 0,\\\\n  \\\"message\\\": \\\"登录成功\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/ebd5a39f8564059c.json": "{\"uid\":\"ebd5a39f8564059c\",\"name\":\"test_order_getall[result0]\",\"fullName\":\"testcases.test_order#test_order_getall\",\"historyId\":\"6a88d5ad1d7de6f85f78d77a9eb85c7f\",\"time\":{\"start\":1705648175590,\"stop\":1705648175627,\"duration\":37},\"status\":\"broken\",\"statusMessage\":\"KeyError: 'message'\",\"statusTrace\":\"result = ('003', 'succ_order_getAll', 'order', 'localhost:3000', '/api/order', 'get', ...)\\ngetToken = &lt;RequestsCookieJar[Cookie(version=0, name='koa.sid', value='JOBKtfj_FylGBbVh644B5AY_YhTqlf_i', port=None, port_specifi...ure=False, expires=1705734575, discard=False, comment=None, comment_url=None, rest={'httponly': None}, rfc2109=False)]&gt;\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_order_getall())\\n    def test_order_getall(result,getToken):\\n        cookie= getToken\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        res = Request.send_request(url, method=request_type, json=dataDict, cookies=cookie).json()\\n        assert  expect_resultDict[\\\"errno\\\"]==res[\\\"errno\\\"]\\n&gt;       assert  expect_resultDict[\\\"message\\\"] ==  res[\\\"message\\\"]\\nE       KeyError: 'message'\\n\\ntestcases\\\\test_order.py:77: KeyError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'succ_order_getAll', 'order', 'localhost:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"ebd5a39f8564059c.json\",\"parameterValues\":[\"('003', 'succ_order_getAll', 'order', 'localhost:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"]}", 
 "data/test-cases/efbba17f563634ff.json": "{\"uid\":\"efbba17f563634ff\",\"name\":\"test_register[res0]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"82854af4d9d1f8526142efab5c28f349\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":6,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"8834dc40085b5894\",\"status\":\"passed\",\"time\":{\"start\":1706176012840,\"stop\":1706176012846,\"duration\":6}},{\"uid\":\"27d27eddc3305046\",\"status\":\"passed\",\"time\":{\"start\":1706175730961,\"stop\":1706175730968,\"duration\":7}},{\"uid\":\"8c81b6cfd82f2126\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 0 == 1001\",\"time\":{\"start\":1706175103835,\"stop\":1706175103840,\"duration\":5}},{\"uid\":\"ab68508ce08448\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 0 == 1001\",\"time\":{\"start\":1706174984567,\"stop\":1706174984575,\"duration\":8}},{\"uid\":\"a42e21610ad5fe5b\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 0 == 1001\",\"time\":{\"start\":1706174957199,\"stop\":1706174957205,\"duration\":6}},{\"uid\":\"caca9913474a0200\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 0 == 1001\",\"time\":{\"start\":1706174854001,\"stop\":1706174854008,\"duration\":7}}],\"categories\":[],\"tags\":[]},\"source\":\"efbba17f563634ff.json\",\"parameterValues\":[\"('004', 'succ-register', 'user', '192.168.0.105:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\":\\\"注册成功\\\"}', '{\\\\n    \\\"errno\\\": 0,\\\\n    \\\"data\\\": {\\\\n        \\\"username\\\": \\\"test222333\\\",\\\\n        \\\"_id\\\": \\\"6599251dba8c71a12392c891\\\",\\\\n        \\\"createdAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"updatedAt\\\": \\\"2024-01-06T10:02:05.636Z\\\",\\\\n        \\\"__v\\\": 0\\\\n    },\\\\n    \\\"message\\\": \\\"注册成功\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/f2cad0279515ab48.json": "{\"uid\":\"f2cad0279515ab48\",\"name\":\"test_delAddressByAid[result1]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"bf300d11c33de14c99079948840baa30\",\"time\":{\"start\":1705648175399,\"stop\":1705648175406,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648175216,\"stop\":1705648175263,\"duration\":47},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1705648175290,\"stop\":1705648175290,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1705648175706,\"stop\":1705648175706,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('009', 'fail-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"f2cad0279515ab48.json\",\"parameterValues\":[\"('009', 'fail-delAddress', 'address', 'localhost:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20023,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/f310db1fc79fd9d5.json": "{\"uid\":\"f310db1fc79fd9d5\",\"name\":\"test_register[result2]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"b175c50ecbde153eef4dd01349cf1e04\",\"time\":{\"start\":1705648175697,\"stop\":1705648175704,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('006', 'error-username_confirmpassword_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"f310db1fc79fd9d5.json\",\"parameterValues\":[\"('006', 'error-username_confirmpassword_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test22233\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/f3ddde2fc782ecd.json": "{\"uid\":\"f3ddde2fc782ecd\",\"name\":\"test_register[result1]\",\"fullName\":\"testcases.test_user#test_register\",\"historyId\":\"4721b9645a0b1f04bafa5256b14beccb\",\"time\":{\"start\":1705648175686,\"stop\":1705648175693,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"5816-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('005', 'error-username_repeat_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"f3ddde2fc782ecd.json\",\"parameterValues\":[\"('005', 'error-username_repeat_fail', 'user', 'localhost:3000', '/api/user/register', 'post', '0', '{\\\"username\\\":\\\"test222333\\\",\\\"password\\\":\\\"test222333\\\",\\\"confirm_password\\\": \\\"test222333\\\"}', '{\\\"errno\\\":1001,\\\"message\\\":\\\"注册失败\\\"}', '{\\\\n    \\\"errno\\\": 1001,\\\\n    \\\"message\\\": \\\"注册失败\\\"\\\\n}', 'miss', 'miss')\"]}", 
 "data/test-cases/f41f8f3868551db9.json": "{\"uid\":\"f41f8f3868551db9\",\"name\":\"test_order_getall[result0]\",\"fullName\":\"testcases.test_order#test_order_getall\",\"historyId\":\"6a88d5ad1d7de6f85f78d77a9eb85c7f\",\"time\":{\"start\":1706176012732,\"stop\":1706176012773,\"duration\":41},\"status\":\"broken\",\"statusMessage\":\"KeyError: 'message'\",\"statusTrace\":\"result = ('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', ...)\\ngetToken = &lt;RequestsCookieJar[Cookie(version=0, name='koa.sid', value='zqgaf00BDG_SABxwNfDQ7QhQ1gbyiICk', port=None, port_specifi...ure=False, expires=1706262412, discard=False, comment=None, comment_url=None, rest={'httponly': None}, rfc2109=False)]&gt;\\n\\n    @pytest.mark.parametrize(\\\"result\\\", data_order_getall())\\n    def test_order_getall(result,getToken):\\n        cookie= getToken\\n        id = result[0]\\n        name = result[1]\\n        module = result[2]\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        need_login = result[6]\\n        data = result[7]\\n        expect_result = result[8]\\n        real_result = result[9]\\n        test_result = result[10]\\n        data_type = result[11]\\n        url = 'http://' + request_prefix + request_url\\n        dataDict = json.loads(data)\\n        expect_resultDict = json.loads(expect_result)\\n        res = Request.send_request(url, method=request_type, json=dataDict, cookies=cookie).json()\\n        assert  expect_resultDict[\\\"errno\\\"]==res[\\\"errno\\\"]\\n&gt;       assert  expect_resultDict[\\\"message\\\"] ==  res[\\\"message\\\"]\\nE       KeyError: 'message'\\n\\ntestcases\\\\test_order.py:77: KeyError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"f41f8f3868551db9.json\",\"parameterValues\":[\"('003', 'succ_order_getAll', 'order', '192.168.0.105:3000', '/api/order', 'get', '1', 'null', '{\\\"errno\\\":0,\\\"data\\\":[]}', '{\\\"errno\\\":0,\\\"data\\\":[]}', 'pass', 'ignore')\"]}", 
 "data/test-cases/f83303d47c163767.json": "{\"uid\":\"f83303d47c163767\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":9,\"retriesStatusChange\":true,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"19216d256fff3d6c\",\"status\":\"passed\",\"time\":{\"start\":1706176012820,\"stop\":1706176012838,\"duration\":18}},{\"uid\":\"c1d370af762a3c42\",\"status\":\"passed\",\"time\":{\"start\":1706175730951,\"stop\":1706175730957,\"duration\":6}},{\"uid\":\"a605a95d5e451326\",\"status\":\"passed\",\"time\":{\"start\":1706175103828,\"stop\":1706175103833,\"duration\":5}},{\"uid\":\"4a1618bd78fb3d9a\",\"status\":\"passed\",\"time\":{\"start\":1706174984556,\"stop\":1706174984562,\"duration\":6}},{\"uid\":\"6668ec183649f57a\",\"status\":\"passed\",\"time\":{\"start\":1706174957191,\"stop\":1706174957196,\"duration\":5}},{\"uid\":\"4c56e82b4db47841\",\"status\":\"passed\",\"time\":{\"start\":1706174853969,\"stop\":1706174853999,\"duration\":30}},{\"uid\":\"7e2d167039e5082b\",\"status\":\"passed\",\"time\":{\"start\":1706174785095,\"stop\":1706174785100,\"duration\":5}},{\"uid\":\"32b06e0816e3d789\",\"status\":\"passed\",\"time\":{\"start\":1706174692817,\"stop\":1706174692837,\"duration\":20}},{\"uid\":\"faf51b4aff6cbf19\",\"status\":\"broken\",\"statusDetails\":\"TypeError: tuple indices must be integers or slices, not str\",\"time\":{\"start\":1706174616544,\"stop\":1706174616544,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"f83303d47c163767.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/faf51b4aff6cbf19.json": "{\"uid\":\"faf51b4aff6cbf19\",\"name\":\"test_login[res2]\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"ec4ffcbb8d9386289e6d1ac4e8004031\",\"time\":{\"start\":1706174616544,\"stop\":1706174616544,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"TypeError: tuple indices must be integers or slices, not str\",\"statusTrace\":\"res = ('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', ...)\\n\\n    @pytest.mark.parametrize(\\\"res\\\", data_login())\\n    def test_login(res):\\n&gt;       id = res['id']\\nE       TypeError: tuple indices must be integers or slices, not str\\n\\ntestcases\\\\test_user.py:30: TypeError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16972-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"res\",\"value\":\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"faf51b4aff6cbf19.json\",\"parameterValues\":[\"('003', 'error-password_fail', 'user', '192.168.0.105:3000', '/api/user/login', 'post', '0', '{\\\"username\\\":\\\"test3\\\",\\\"password\\\":\\\"test\\\"}', '{\\\"errno\\\":1002,\\\"message\\\":\\\"登录失败\\\"}', '{\\\\n    \\\"errno\\\": 1002,\\\\n    \\\"message\\\": \\\"登录失败\\\"\\\\n}', 'pass', 'miss')\"]}", 
 "data/test-cases/faf5ca61d101cd27.json": "{\"uid\":\"faf5ca61d101cd27\",\"name\":\"test_login\",\"fullName\":\"testcases.test_user#test_login\",\"historyId\":\"1473ef8c673a8ff79040e670e3f8c75e\",\"time\":{\"start\":1706120368292,\"stop\":1706120368292,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"TypeError: 'list' object cannot be interpreted as an integer\",\"statusTrace\":\"request = &lt;SubRequest 'data_login' for &lt;Function test_login&gt;&gt;\\ngetDBConnection = &lt;db.db.DB object at 0x000002443BA7F310&gt;\\n\\n    @pytest.fixture()\\n    def data_login(request,getDBConnection):\\n        db = getDBConnection\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE (id = '001' OR id = '002' OR id = '003') \\\" \\\\\\n              \\\"AND (name='succ-login' OR name='error-username_fail' OR name='error-password_fail')\\\"\\n        data = db.executeSql(SQL)\\n&gt;       request.param = [buildObj(x) for x in range(list(data))]\\nE       TypeError: 'list' object cannot be interpreted as an integer\\n\\ntestcases\\\\test_user.py:43: TypeError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getDBConnection\",\"time\":{\"start\":1706120368294,\"stop\":1706120368298,\"duration\":4},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"data_login\",\"time\":{\"start\":1706120368298,\"stop\":1706120368299,\"duration\":1},\"status\":\"broken\",\"statusMessage\":\"TypeError: 'list' object cannot be interpreted as an integer\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 908, in call_fixture_func\\n    fixture_result = fixturefunc(**kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\testcases\\\\test_user.py\\\", line 43, in data_login\\n    request.param = [buildObj(x) for x in range(list(data))]\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getDBConnection::0\",\"time\":{\"start\":1706120368415,\"stop\":1706120368415,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_user\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16792-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_user\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"faf5ca61d101cd27.json\",\"parameterValues\":[]}", 
 "data/test-cases/fbd00a4f1636ad74.json": "{\"uid\":\"fbd00a4f1636ad74\",\"name\":\"test_getDeafultAddress[result0]\",\"fullName\":\"testcases.test_address#test_getDeafultAddress\",\"historyId\":\"bd779856aa83a555802f97899913cdfc\",\"time\":{\"start\":1706176012587,\"stop\":1706176012592,\"duration\":5},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"fbd00a4f1636ad74.json\",\"parameterValues\":[\"('010', 'succ-getDefaultAddress', 'address', '192.168.0.105:3000', '/api/user/address/default', 'get', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"返回默认地址\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/fc2c79a47e8a0be2.json": "{\"uid\":\"fc2c79a47e8a0be2\",\"name\":\"test_order_submit[result0]\",\"fullName\":\"testcases.test_order#test_order_submit\",\"historyId\":\"354f8fc0730a8289cdb844d5db741a9b\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":4,\"retriesStatusChange\":true,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176287669,\"stop\":1706176287677,\"duration\":8},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176287964,\"stop\":1706176287964,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_order\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16640-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_order\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"}],\"links\":[],\"hidden\":false,\"retry\":false,\"extra\":{\"severity\":\"normal\",\"retries\":[{\"uid\":\"a564f466e85d11d2\",\"status\":\"passed\",\"time\":{\"start\":1706176012595,\"stop\":1706176012609,\"duration\":14}},{\"uid\":\"d53f6d70a9c81d71\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235656B9BA0&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024562709,\"stop\":1706024562709,\"duration\":0}},{\"uid\":\"463a5bd2f13d8a62\",\"status\":\"passed\",\"time\":{\"start\":1705648175421,\"stop\":1705648175444,\"duration\":23}},{\"uid\":\"e48f4a8ea6ffe578\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1705648143659,\"stop\":1705648143659,\"duration\":0}}],\"categories\":[],\"tags\":[]},\"source\":\"fc2c79a47e8a0be2.json\",\"parameterValues\":[\"('001', 'succ_order_commit', 'order', '192.168.0.105:3000', '/api/order', 'post', '1', '{ \\\"addressId\\\": \\\"65911082a15c394008104f13\\\",\\\"shopId\\\": \\\"63540080e1cb5c6273a3f79b\\\",\\\"shopName\\\": \\\"沃尔玛\\\",\\\"isCanceled\\\": true,\\\"products\\\": [{ \\\"id\\\": \\\"63540e05505487ac300338a4\\\", \\\"num\\\": 3 },{ \\\"id\\\": \\\"63540e05505487ac300338a7\\\", \\\"num\\\": 4 }]}\\\\r\\\\n', '{\\\"errno\\\":0,\\\"data\\\":{},\\\"message\\\": \\\"创建订单成功\\\"}', '{\\\"errno\\\": 0,\\\"data\\\": {},\\\"message\\\": \\\"创建订单成功\\\"}', 'pass', 'ignore')\"]}", 
 "data/test-cases/fdbdaea3ad155ee1.json": "{\"uid\":\"fdbdaea3ad155ee1\",\"name\":\"test_addNewAddress[result1]\",\"fullName\":\"testcases.test_address#test_addNewAddress\",\"historyId\":\"c8b1d81f71261fd9b020151ebd96af7e\",\"time\":{\"start\":1705648142740,\"stop\":1705648142740,\"duration\":0},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"statusTrace\":\"self = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n&gt;           sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:203: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n                sock.connect(sa)\\n                # Break explicitly a reference cycle\\n                err = None\\n                return sock\\n    \\n            except OSError as _:\\n                err = _\\n                if sock is not None:\\n                    sock.close()\\n    \\n        if err is not None:\\n            try:\\n&gt;               raise err\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:85: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\naddress = ('localhost', 3000), timeout = 1000, source_address = None\\nsocket_options = [(6, 1, 1)]\\n\\n    def create_connection(\\n        address: tuple[str, int],\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        source_address: tuple[str, int] | None = None,\\n        socket_options: _TYPE_SOCKET_OPTIONS | None = None,\\n    ) -&gt; socket.socket:\\n        \\\"\\\"\\\"Connect to *address* and return the socket object.\\n    \\n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\\n        port)``) and return the socket object.  Passing the optional\\n        *timeout* parameter will set the timeout on the socket instance\\n        before attempting to connect.  If no *timeout* is supplied, the\\n        global default timeout setting returned by :func:`socket.getdefaulttimeout`\\n        is used.  If *source_address* is set it must be a tuple of (host, port)\\n        for the socket to bind as a source address before making the connection.\\n        An host of '' or port 0 tells the OS to use the default.\\n        \\\"\\\"\\\"\\n    \\n        host, port = address\\n        if host.startswith(\\\"[\\\"):\\n            host = host.strip(\\\"[]\\\")\\n        err = None\\n    \\n        # Using the value from allowed_gai_family() in the context of getaddrinfo lets\\n        # us select whether to work with IPv4 DNS records, IPv6 records, or both.\\n        # The original create_connection function always returns all records.\\n        family = allowed_gai_family()\\n    \\n        try:\\n            host.encode(\\\"idna\\\")\\n        except UnicodeError:\\n            raise LocationParseError(f\\\"'{host}', label empty or too long\\\") from None\\n    \\n        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\\n            af, socktype, proto, canonname, sa = res\\n            sock = None\\n            try:\\n                sock = socket.socket(af, socktype, proto)\\n    \\n                # If provided, set socket level options before connecting.\\n                _set_socket_options(sock, socket_options)\\n    \\n                if timeout is not _DEFAULT_TIMEOUT:\\n                    sock.settimeout(timeout)\\n                if source_address:\\n                    sock.bind(source_address)\\n&gt;               sock.connect(sa)\\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\connection.py:73: ConnectionRefusedError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n&gt;           response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:790: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nconn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\ntimeout = Timeout(connect=1000, read=1000, total=None), chunked = False\\nresponse_conn = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\npreload_content = False, decode_content = False, enforce_content_length = True\\n\\n    def _make_request(\\n        self,\\n        conn: BaseHTTPConnection,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | None = None,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        chunked: bool = False,\\n        response_conn: BaseHTTPConnection | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Perform a request on a given urllib connection object taken from our\\n        pool.\\n    \\n        :param conn:\\n            a connection from one of our connection pools\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param response_conn:\\n            Set this to ``None`` if you will handle releasing the connection or\\n            set the connection to have the response release it.\\n    \\n        :param preload_content:\\n          If True, the response's body will be preloaded during construction.\\n    \\n        :param decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param enforce_content_length:\\n            Enforce content length checking. Body returned by server must match\\n            value of Content-Length header, if present. Otherwise, raise error.\\n        \\\"\\\"\\\"\\n        self.num_requests += 1\\n    \\n        timeout_obj = self._get_timeout(timeout)\\n        timeout_obj.start_connect()\\n        conn.timeout = Timeout.resolve_default_timeout(timeout_obj.connect_timeout)\\n    \\n        try:\\n            # Trigger any extra validation we need to do.\\n            try:\\n                self._validate_conn(conn)\\n            except (SocketTimeout, BaseSSLError) as e:\\n                self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\\n                raise\\n    \\n        # _validate_conn() starts the connection to an HTTPS proxy\\n        # so we need to wrap errors with 'ProxyError' here too.\\n        except (\\n            OSError,\\n            NewConnectionError,\\n            TimeoutError,\\n            BaseSSLError,\\n            CertificateError,\\n            SSLError,\\n        ) as e:\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            # If the connection didn't successfully connect to it's proxy\\n            # then there\\n            if isinstance(\\n                new_e, (OSError, NewConnectionError, TimeoutError, SSLError)\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            raise new_e\\n    \\n        # conn.request() calls http.client.*.request, not the method in\\n        # urllib3.request. It also calls makefile (recv) on the socket.\\n        try:\\n&gt;           conn.request(\\n                method,\\n                url,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                enforce_content_length=enforce_content_length,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:496: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\n\\n    def request(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        *,\\n        chunked: bool = False,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        enforce_content_length: bool = True,\\n    ) -&gt; None:\\n        # Update the inner socket's timeout value to send the request.\\n        # This only triggers if the connection is re-used.\\n        if self.sock is not None:\\n            self.sock.settimeout(self.timeout)\\n    \\n        # Store these values to be fed into the HTTPResponse\\n        # object later. TODO: Remove this in favor of a real\\n        # HTTP lifecycle mechanism.\\n    \\n        # We have to store these before we call .request()\\n        # because sometimes we can still salvage a response\\n        # off the wire even if we aren't able to completely\\n        # send the request body.\\n        self._response_options = _ResponseOptions(\\n            request_method=method,\\n            request_url=url,\\n            preload_content=preload_content,\\n            decode_content=decode_content,\\n            enforce_content_length=enforce_content_length,\\n        )\\n    \\n        if headers is None:\\n            headers = {}\\n        header_keys = frozenset(to_str(k.lower()) for k in headers)\\n        skip_accept_encoding = \\\"accept-encoding\\\" in header_keys\\n        skip_host = \\\"host\\\" in header_keys\\n        self.putrequest(\\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\\n        )\\n    \\n        # Transform the body into an iterable of sendall()-able chunks\\n        # and detect if an explicit Content-Length is doable.\\n        chunks_and_cl = body_to_chunks(body, method=method, blocksize=self.blocksize)\\n        chunks = chunks_and_cl.chunks\\n        content_length = chunks_and_cl.content_length\\n    \\n        # When chunked is explicit set to 'True' we respect that.\\n        if chunked:\\n            if \\\"transfer-encoding\\\" not in header_keys:\\n                self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n        else:\\n            # Detect whether a framing mechanism is already in use. If so\\n            # we respect that value, otherwise we pick chunked vs content-length\\n            # depending on the type of 'body'.\\n            if \\\"content-length\\\" in header_keys:\\n                chunked = False\\n            elif \\\"transfer-encoding\\\" in header_keys:\\n                chunked = True\\n    \\n            # Otherwise we go off the recommendation of 'body_to_chunks()'.\\n            else:\\n                chunked = False\\n                if content_length is None:\\n                    if chunks is not None:\\n                        chunked = True\\n                        self.putheader(\\\"Transfer-Encoding\\\", \\\"chunked\\\")\\n                else:\\n                    self.putheader(\\\"Content-Length\\\", str(content_length))\\n    \\n        # Now that framing headers are out of the way we send all the other headers.\\n        if \\\"user-agent\\\" not in header_keys:\\n            self.putheader(\\\"User-Agent\\\", _get_default_user_agent())\\n        for header, value in headers.items():\\n            self.putheader(header, value)\\n&gt;       self.endheaders()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:395: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None\\n\\n    def endheaders(self, message_body=None, *, encode_chunked=False):\\n        \\\"\\\"\\\"Indicate that the last header line has been sent to the server.\\n    \\n        This method sends the request to the server.  The optional message_body\\n        argument can be used to pass a message body associated with the\\n        request.\\n        \\\"\\\"\\\"\\n        if self.__state == _CS_REQ_STARTED:\\n            self.__state = _CS_REQ_SENT\\n        else:\\n            raise CannotSendHeader()\\n&gt;       self._send_output(message_body, encode_chunked=encode_chunked)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1278: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\nmessage_body = None, encode_chunked = False\\n\\n    def _send_output(self, message_body=None, encode_chunked=False):\\n        \\\"\\\"\\\"Send the currently buffered request and clear the buffer.\\n    \\n        Appends an extra \\\\\\\\r\\\\\\\\n to the buffer.\\n        A message_body may be specified, to be appended to the request.\\n        \\\"\\\"\\\"\\n        self._buffer.extend((b\\\"\\\", b\\\"\\\"))\\n        msg = b\\\"\\\\r\\\\n\\\".join(self._buffer)\\n        del self._buffer[:]\\n&gt;       self.send(msg)\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:1038: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\ndata = b'POST /api/user/login HTTP/1.1\\\\r\\\\nHost: localhost:3000\\\\r\\\\nUser-Agent: python-requests/2.31.0\\\\r\\\\nAccept-Encoding: gzip...Accept: */*\\\\r\\\\nConnection: keep-alive\\\\r\\\\nContent-Length: 29\\\\r\\\\nContent-Type: application/x-www-form-urlencoded\\\\r\\\\n\\\\r\\\\n'\\n\\n    def send(self, data):\\n        \\\"\\\"\\\"Send `data' to the server.\\n        ``data`` can be a string object, a bytes object, an array object, a\\n        file-like object that supports a .read() method, or an iterable object.\\n        \\\"\\\"\\\"\\n    \\n        if self.sock is None:\\n            if self.auto_open:\\n&gt;               self.connect()\\n\\nC:\\\\python3_10\\\\lib\\\\http\\\\client.py:976: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def connect(self) -&gt; None:\\n&gt;       self.sock = self._new_conn()\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:243: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;\\n\\n    def _new_conn(self) -&gt; socket.socket:\\n        \\\"\\\"\\\"Establish a socket connection and set nodelay settings on it.\\n    \\n        :return: New socket connection.\\n        \\\"\\\"\\\"\\n        try:\\n            sock = connection.create_connection(\\n                (self._dns_host, self.port),\\n                self.timeout,\\n                source_address=self.source_address,\\n                socket_options=self.socket_options,\\n            )\\n        except socket.gaierror as e:\\n            raise NameResolutionError(self.host, self, e) from e\\n        except SocketTimeout as e:\\n            raise ConnectTimeoutError(\\n                self,\\n                f\\\"Connection to {self.host} timed out. (connect timeout={self.timeout})\\\",\\n            ) from e\\n    \\n        except OSError as e:\\n&gt;           raise NewConnectionError(\\n                self, f\\\"Failed to establish a new connection: {e}\\\"\\n            ) from e\\nE           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connection.py:218: NewConnectionError\\n\\nThe above exception was the direct cause of the following exception:\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n&gt;           resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:486: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\nmethod = 'POST', url = '/api/user/login', body = 'username=test3&password=test3'\\nheaders = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '29', 'Content-Type': 'application/x-www-form-urlencoded'}\\nretries = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nredirect = False, assert_same_host = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), pool_timeout = None\\nrelease_conn = False, chunked = False, body_pos = None, preload_content = False\\ndecode_content = False, response_kw = {}\\nparsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/user/login', query=None, fragment=None)\\ndestination_scheme = None, conn = None, release_this_conn = True\\nhttp_tunnel_required = False, err = None, clean_exit = False\\n\\n    def urlopen(  # type: ignore[override]\\n        self,\\n        method: str,\\n        url: str,\\n        body: _TYPE_BODY | None = None,\\n        headers: typing.Mapping[str, str] | None = None,\\n        retries: Retry | bool | int | None = None,\\n        redirect: bool = True,\\n        assert_same_host: bool = True,\\n        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,\\n        pool_timeout: int | None = None,\\n        release_conn: bool | None = None,\\n        chunked: bool = False,\\n        body_pos: _TYPE_BODY_POSITION | None = None,\\n        preload_content: bool = True,\\n        decode_content: bool = True,\\n        **response_kw: typing.Any,\\n    ) -&gt; BaseHTTPResponse:\\n        \\\"\\\"\\\"\\n        Get a connection from the pool and perform an HTTP request. This is the\\n        lowest level call for making a request, so you'll need to specify all\\n        the raw details.\\n    \\n        .. note::\\n    \\n           More commonly, it's appropriate to use a convenience method\\n           such as :meth:`request`.\\n    \\n        .. note::\\n    \\n           `release_conn` will only behave as expected if\\n           `preload_content=False` because we want to make\\n           `preload_content=False` the default behaviour someday soon without\\n           breaking backwards compatibility.\\n    \\n        :param method:\\n            HTTP request method (such as GET, POST, PUT, etc.)\\n    \\n        :param url:\\n            The URL to perform the request on.\\n    \\n        :param body:\\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\\n    \\n        :param headers:\\n            Dictionary of custom headers to send, such as User-Agent,\\n            If-None-Match, etc. If None, pool headers are used. If provided,\\n            these headers completely replace any pool-specific headers.\\n    \\n        :param retries:\\n            Configure the number of retries to allow before raising a\\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\\n    \\n            Pass ``None`` to retry until you receive a response. Pass a\\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\\n            over different types of retries.\\n            Pass an integer number to retry connection errors that many times,\\n            but no other types of errors. Pass zero to never retry.\\n    \\n            If ``False``, then retries are disabled and any exception is raised\\n            immediately. Also, instead of raising a MaxRetryError on redirects,\\n            the redirect response will be returned.\\n    \\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\\n    \\n        :param redirect:\\n            If True, automatically handle redirects (status codes 301, 302,\\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\\n            will disable redirect, too.\\n    \\n        :param assert_same_host:\\n            If ``True``, will make sure that the host of the pool requests is\\n            consistent else will raise HostChangedError. When ``False``, you can\\n            use the pool on an HTTP proxy and request foreign hosts.\\n    \\n        :param timeout:\\n            If specified, overrides the default timeout for this one\\n            request. It may be a float (in seconds) or an instance of\\n            :class:`urllib3.util.Timeout`.\\n    \\n        :param pool_timeout:\\n            If set and the pool is set to block=True, then this method will\\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\\n            connection is available within the time period.\\n    \\n        :param bool preload_content:\\n            If True, the response's body will be preloaded into memory.\\n    \\n        :param bool decode_content:\\n            If True, will attempt to decode the body based on the\\n            'content-encoding' header.\\n    \\n        :param release_conn:\\n            If False, then the urlopen call will not release the connection\\n            back into the pool once a response is received (but will release if\\n            you read the entire contents of the response such as when\\n            `preload_content=True`). This is useful if you're not preloading\\n            the response's content immediately. You will need to call\\n            ``r.release_conn()`` on the response ``r`` to return the connection\\n            back into the pool. If None, it takes the value of ``preload_content``\\n            which defaults to ``True``.\\n    \\n        :param bool chunked:\\n            If True, urllib3 will send the body using chunked transfer\\n            encoding. Otherwise, urllib3 will send the body using the standard\\n            content-length form. Defaults to False.\\n    \\n        :param int body_pos:\\n            Position to seek to in file-like body in the event of a retry or\\n            redirect. Typically this won't need to be set because urllib3 will\\n            auto-populate the value when needed.\\n        \\\"\\\"\\\"\\n        parsed_url = parse_url(url)\\n        destination_scheme = parsed_url.scheme\\n    \\n        if headers is None:\\n            headers = self.headers\\n    \\n        if not isinstance(retries, Retry):\\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\\n    \\n        if release_conn is None:\\n            release_conn = preload_content\\n    \\n        # Check host\\n        if assert_same_host and not self.is_same_host(url):\\n            raise HostChangedError(self, url, retries)\\n    \\n        # Ensure that the URL we're connecting to is properly encoded\\n        if url.startswith(\\\"/\\\"):\\n            url = to_str(_encode_target(url))\\n        else:\\n            url = to_str(parsed_url.url)\\n    \\n        conn = None\\n    \\n        # Track whether `conn` needs to be released before\\n        # returning/raising/recursing. Update this variable if necessary, and\\n        # leave `release_conn` constant throughout the function. That way, if\\n        # the function recurses, the original value of `release_conn` will be\\n        # passed down into the recursive call, and its value will be respected.\\n        #\\n        # See issue #651 [1] for details.\\n        #\\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\\n        release_this_conn = release_conn\\n    \\n        http_tunnel_required = connection_requires_http_tunnel(\\n            self.proxy, self.proxy_config, destination_scheme\\n        )\\n    \\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\\n        # have to copy the headers dict so we can safely change it without those\\n        # changes being reflected in anyone else's copy.\\n        if not http_tunnel_required:\\n            headers = headers.copy()  # type: ignore[attr-defined]\\n            headers.update(self.proxy_headers)  # type: ignore[union-attr]\\n    \\n        # Must keep the exception bound to a separate variable or else Python 3\\n        # complains about UnboundLocalError.\\n        err = None\\n    \\n        # Keep track of whether we cleanly exited the except block. This\\n        # ensures we do proper cleanup in finally.\\n        clean_exit = False\\n    \\n        # Rewind body position, if needed. Record current position\\n        # for future rewinds in the event of a redirect/retry.\\n        body_pos = set_file_position(body, body_pos)\\n    \\n        try:\\n            # Request a connection from the queue.\\n            timeout_obj = self._get_timeout(timeout)\\n            conn = self._get_conn(timeout=pool_timeout)\\n    \\n            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]\\n    \\n            # Is this a closed/new connection that requires CONNECT tunnelling?\\n            if self.proxy is not None and http_tunnel_required and conn.is_closed:\\n                try:\\n                    self._prepare_proxy(conn)\\n                except (BaseSSLError, OSError, SocketTimeout) as e:\\n                    self._raise_timeout(\\n                        err=e, url=self.proxy.url, timeout_value=conn.timeout\\n                    )\\n                    raise\\n    \\n            # If we're going to release the connection in ``finally:``, then\\n            # the response doesn't need to know about the connection. Otherwise\\n            # it will also try to release it and we'll have a double-release\\n            # mess.\\n            response_conn = conn if not release_conn else None\\n    \\n            # Make the request on the HTTPConnection object\\n            response = self._make_request(\\n                conn,\\n                method,\\n                url,\\n                timeout=timeout_obj,\\n                body=body,\\n                headers=headers,\\n                chunked=chunked,\\n                retries=retries,\\n                response_conn=response_conn,\\n                preload_content=preload_content,\\n                decode_content=decode_content,\\n                **response_kw,\\n            )\\n    \\n            # Everything went great!\\n            clean_exit = True\\n    \\n        except EmptyPoolError:\\n            # Didn't get a connection from the pool, no need to clean up\\n            clean_exit = True\\n            release_this_conn = False\\n            raise\\n    \\n        except (\\n            TimeoutError,\\n            HTTPException,\\n            OSError,\\n            ProtocolError,\\n            BaseSSLError,\\n            SSLError,\\n            CertificateError,\\n            ProxyError,\\n        ) as e:\\n            # Discard the connection for these exceptions. It will be\\n            # replaced during the next _get_conn() call.\\n            clean_exit = False\\n            new_e: Exception = e\\n            if isinstance(e, (BaseSSLError, CertificateError)):\\n                new_e = SSLError(e)\\n            if isinstance(\\n                new_e,\\n                (\\n                    OSError,\\n                    NewConnectionError,\\n                    TimeoutError,\\n                    SSLError,\\n                    HTTPException,\\n                ),\\n            ) and (conn and conn.proxy and not conn.has_connected_to_proxy):\\n                new_e = _wrap_proxy_error(new_e, conn.proxy.scheme)\\n            elif isinstance(new_e, (OSError, HTTPException)):\\n                new_e = ProtocolError(\\\"Connection aborted.\\\", new_e)\\n    \\n&gt;           retries = retries.increment(\\n                method, url, error=new_e, _pool=self, _stacktrace=sys.exc_info()[2]\\n            )\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\connectionpool.py:844: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = Retry(total=0, connect=None, read=False, redirect=None, status=None)\\nmethod = 'POST', url = '/api/user/login', response = None\\nerror = NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')\\n_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x00000153093995D0&gt;\\n_stacktrace = &lt;traceback object at 0x000001530932CCC0&gt;\\n\\n    def increment(\\n        self,\\n        method: str | None = None,\\n        url: str | None = None,\\n        response: BaseHTTPResponse | None = None,\\n        error: Exception | None = None,\\n        _pool: ConnectionPool | None = None,\\n        _stacktrace: TracebackType | None = None,\\n    ) -&gt; Retry:\\n        \\\"\\\"\\\"Return a new Retry object with incremented retry counters.\\n    \\n        :param response: A response object, or None, if the server did not\\n            return a response.\\n        :type response: :class:`~urllib3.response.BaseHTTPResponse`\\n        :param Exception error: An error encountered during the request, or\\n            None if the response was received successfully.\\n    \\n        :return: A new ``Retry`` object.\\n        \\\"\\\"\\\"\\n        if self.total is False and error:\\n            # Disabled, indicate to re-raise the error.\\n            raise reraise(type(error), error, _stacktrace)\\n    \\n        total = self.total\\n        if total is not None:\\n            total -= 1\\n    \\n        connect = self.connect\\n        read = self.read\\n        redirect = self.redirect\\n        status_count = self.status\\n        other = self.other\\n        cause = \\\"unknown\\\"\\n        status = None\\n        redirect_location = None\\n    \\n        if error and self._is_connection_error(error):\\n            # Connect retry?\\n            if connect is False:\\n                raise reraise(type(error), error, _stacktrace)\\n            elif connect is not None:\\n                connect -= 1\\n    \\n        elif error and self._is_read_error(error):\\n            # Read retry?\\n            if read is False or method is None or not self._is_method_retryable(method):\\n                raise reraise(type(error), error, _stacktrace)\\n            elif read is not None:\\n                read -= 1\\n    \\n        elif error:\\n            # Other retry?\\n            if other is not None:\\n                other -= 1\\n    \\n        elif response and response.get_redirect_location():\\n            # Redirect retry?\\n            if redirect is not None:\\n                redirect -= 1\\n            cause = \\\"too many redirects\\\"\\n            response_redirect_location = response.get_redirect_location()\\n            if response_redirect_location:\\n                redirect_location = response_redirect_location\\n            status = response.status\\n    \\n        else:\\n            # Incrementing because of a server error like a 500 in\\n            # status_forcelist and the given method is in the allowed_methods\\n            cause = ResponseError.GENERIC_ERROR\\n            if response and response.status:\\n                if status_count is not None:\\n                    status_count -= 1\\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\\n                status = response.status\\n    \\n        history = self.history + (\\n            RequestHistory(method, url, error, status, redirect_location),\\n        )\\n    \\n        new_retry = self.new(\\n            total=total,\\n            connect=connect,\\n            read=read,\\n            redirect=redirect,\\n            status=status_count,\\n            other=other,\\n            history=history,\\n        )\\n    \\n        if new_retry.is_exhausted():\\n            reason = error or ResponseError(cause)\\n&gt;           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]\\nE           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\urllib3\\\\util\\\\retry.py:515: MaxRetryError\\n\\nDuring handling of the above exception, another exception occurred:\\n\\n    @pytest.fixture(scope='session')\\n    def getToken():\\n        print('module start')\\n        db = DB()\\n        SQL = \\\"SELECT * from user \\\" \\\\\\n              \\\"WHERE id = '001' AND name='succ-login' \\\"\\n        data = db.executeSql(SQL)\\n        result = list(chain.from_iterable(data))\\n        # print('result==&gt;', result, type(result))\\n        request_prefix = result[3]\\n        request_url = result[4]\\n        request_type = result[5]\\n        data = result[7]\\n        dataDict = json.loads(data)\\n        url = 'http://' + request_prefix + request_url\\n&gt;       res = Request.send_request(url, method=request_type, data=dataDict)\\n\\nconftest.py:30: \\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\nutils\\\\request.py:20: in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:115: in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\api.py:59: in request\\n    return session.request(method=method, url=url, **kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:589: in request\\n    resp = self.send(prep, **send_kwargs)\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py:703: in send\\n    r = adapter.send(request, **kwargs)\\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n\\nself = &lt;requests.adapters.HTTPAdapter object at 0x00000153093993F0&gt;\\nrequest = &lt;PreparedRequest [POST]&gt;, stream = False\\ntimeout = Timeout(connect=1000, read=1000, total=None), verify = True\\ncert = None, proxies = OrderedDict()\\n\\n    def send(\\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\\n    ):\\n        \\\"\\\"\\\"Sends PreparedRequest object. Returns Response object.\\n    \\n        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.\\n        :param stream: (optional) Whether to stream the request content.\\n        :param timeout: (optional) How long to wait for the server to send\\n            data before giving up, as a float, or a :ref:`(connect timeout,\\n            read timeout) &lt;timeouts&gt;` tuple.\\n        :type timeout: float or tuple or urllib3 Timeout object\\n        :param verify: (optional) Either a boolean, in which case it controls whether\\n            we verify the server's TLS certificate, or a string, in which case it\\n            must be a path to a CA bundle to use\\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\\n        :param proxies: (optional) The proxies dictionary to apply to the request.\\n        :rtype: requests.Response\\n        \\\"\\\"\\\"\\n    \\n        try:\\n            conn = self.get_connection(request.url, proxies)\\n        except LocationValueError as e:\\n            raise InvalidURL(e, request=request)\\n    \\n        self.cert_verify(conn, request.url, verify, cert)\\n        url = self.request_url(request, proxies)\\n        self.add_headers(\\n            request,\\n            stream=stream,\\n            timeout=timeout,\\n            verify=verify,\\n            cert=cert,\\n            proxies=proxies,\\n        )\\n    \\n        chunked = not (request.body is None or \\\"Content-Length\\\" in request.headers)\\n    \\n        if isinstance(timeout, tuple):\\n            try:\\n                connect, read = timeout\\n                timeout = TimeoutSauce(connect=connect, read=read)\\n            except ValueError:\\n                raise ValueError(\\n                    f\\\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \\\"\\n                    f\\\"or a single float to set both timeouts to the same value.\\\"\\n                )\\n        elif isinstance(timeout, TimeoutSauce):\\n            pass\\n        else:\\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\\n    \\n        try:\\n            resp = conn.urlopen(\\n                method=request.method,\\n                url=url,\\n                body=request.body,\\n                headers=request.headers,\\n                redirect=False,\\n                assert_same_host=False,\\n                preload_content=False,\\n                decode_content=False,\\n                retries=self.max_retries,\\n                timeout=timeout,\\n                chunked=chunked,\\n            )\\n    \\n        except (ProtocolError, OSError) as err:\\n            raise ConnectionError(err, request=request)\\n    \\n        except MaxRetryError as e:\\n            if isinstance(e.reason, ConnectTimeoutError):\\n                # TODO: Remove this in 3.0.0: see #2811\\n                if not isinstance(e.reason, NewConnectionError):\\n                    raise ConnectTimeout(e, request=request)\\n    \\n            if isinstance(e.reason, ResponseError):\\n                raise RetryError(e, request=request)\\n    \\n            if isinstance(e.reason, _ProxyError):\\n                raise ProxyError(e, request=request)\\n    \\n            if isinstance(e.reason, _SSLError):\\n                # This branch is for urllib3 v1.22 and later.\\n                raise SSLError(e, request=request)\\n    \\n&gt;           raise ConnectionError(e, request=request)\\nE           requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\\nvenv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py:519: ConnectionError\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1705648138300,\"stop\":1705648142395,\"duration\":4095},\"status\":\"broken\",\"statusMessage\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='localhost', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000015309399C30&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\\n\",\"statusTrace\":\"  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\pluggy\\\\_callers.py\\\", line 39, in _multicall\\n    res = hook_impl.function(*args)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 1129, in pytest_fixture_setup\\n    result = call_fixture_func(fixturefunc, request, kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\_pytest\\\\fixtures.py\\\", line 901, in call_fixture_func\\n    fixture_result = next(generator)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\conftest.py\\\", line 30, in getToken\\n    res = Request.send_request(url, method=request_type, data=dataDict)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\utils\\\\request.py\\\", line 20, in send_request\\n    result = requests.post(url, data=data, cookies=cookies, timeout=timeout)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 115, in post\\n    return request(\\\"post\\\", url, data=data, json=json, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\api.py\\\", line 59, in request\\n    return session.request(method=method, url=url, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 589, in request\\n    resp = self.send(prep, **send_kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\sessions.py\\\", line 703, in send\\n    r = adapter.send(request, **kwargs)\\n  File \\\"C:\\\\Users\\\\lv\\\\Desktop\\\\fangjindong\\\\fangJD\\\\venv\\\\lib\\\\site-packages\\\\requests\\\\adapters.py\\\", line 519, in send\\n    raise ConnectionError(e, request=request)\\n\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":true,\"hasContent\":true,\"stepsCount\":0}],\"afterStages\":[],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"16060-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('003', 'fail-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"fdbdaea3ad155ee1.json\",\"parameterValues\":[\"('003', 'fail-addNewAddress', 'address', 'localhost:3000', '/api/user/address', 'post', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 20021,\\\\r\\\\n  \\\"message\\\": \\\"创建地址失败\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "data/test-cases/fe2fa76f95d27044.json": "{\"uid\":\"fe2fa76f95d27044\",\"name\":\"test_delAddressByAid[result0]\",\"fullName\":\"testcases.test_address#test_delAddressByAid\",\"historyId\":\"c52b47aedbefdd9435ae90087b7849b3\",\"time\":{\"start\":1706176012548,\"stop\":1706176012555,\"duration\":7},\"status\":\"passed\",\"flaky\":false,\"newFailed\":false,\"newBroken\":false,\"newPassed\":false,\"retriesCount\":0,\"retriesStatusChange\":false,\"beforeStages\":[{\"name\":\"getToken\",\"time\":{\"start\":1706176012453,\"stop\":1706176012460,\"duration\":7},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0},{\"name\":\"global_data\",\"time\":{\"start\":1706176012480,\"stop\":1706176012480,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"afterStages\":[{\"name\":\"getToken::0\",\"time\":{\"start\":1706176012885,\"stop\":1706176012885,\"duration\":0},\"status\":\"passed\",\"steps\":[],\"attachments\":[],\"parameters\":[],\"attachmentsCount\":0,\"shouldDisplayMessage\":false,\"hasContent\":false,\"stepsCount\":0}],\"labels\":[{\"name\":\"parentSuite\",\"value\":\"testcases\"},{\"name\":\"suite\",\"value\":\"test_address\"},{\"name\":\"host\",\"value\":\"DESKTOP-061EAN7\"},{\"name\":\"thread\",\"value\":\"10508-MainThread\"},{\"name\":\"framework\",\"value\":\"pytest\"},{\"name\":\"language\",\"value\":\"cpython3\"},{\"name\":\"package\",\"value\":\"testcases.test_address\"},{\"name\":\"resultFormat\",\"value\":\"allure2\"}],\"parameters\":[{\"name\":\"result\",\"value\":\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"}],\"links\":[],\"hidden\":true,\"retry\":true,\"extra\":{\"categories\":[],\"tags\":[]},\"source\":\"fe2fa76f95d27044.json\",\"parameterValues\":[\"('008', 'succ-delAddress', 'address', '192.168.0.105:3000', '/api/user/address/aid/', 'delete', '1', 'null', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', '{\\\\r\\\\n  \\\"errno\\\": 0,\\\\r\\\\n  \\\"data\\\": {},\\\\r\\\\n  \\\"message\\\": \\\"删除成功\\\"\\\\r\\\\n}\\\\r\\\\n', 'miss', 'ignore')\"]}", 
 "export/influxDbData.txt": "launch_status failed=2 1706345332000000000\nlaunch_status broken=4 1706345332000000000\nlaunch_status passed=20 1706345332000000000\nlaunch_status skipped=0 1706345332000000000\nlaunch_status unknown=0 1706345332000000000\nlaunch_time duration=151724804 1706345332000000000\nlaunch_time min_duration=0 1706345332000000000\nlaunch_time max_duration=2018 1706345332000000000\nlaunch_time sum_duration=6210 1706345332000000000\nlaunch_problems product_defects=2 1706345332000000000\nlaunch_problems test_defects=4 1706345332000000000\nlaunch_retries retries=117 1706345332000000000\nlaunch_retries run=26 1706345332000000000\n", 
 "export/mail.html": "data:text/html;base64, PCFET0NUWVBFIGh0bWw+CjxodG1sPgo8aGVhZD4KICAgIDxtZXRhIGNoYXJzZXQ9InV0Zi04Ij4KICAgIDx0aXRsZT5BbGx1cmUgUmVwb3J0IHN1bW1hcnkgbWFpbDwvdGl0bGU+CjwvaGVhZD4KPGJvZHk+CiAgICBNYWlsIGJvZHkKPC9ib2R5Pgo8L2h0bWw+Cg==", 
 "export/prometheusData.txt": "launch_status_failed 2\nlaunch_status_broken 4\nlaunch_status_passed 20\nlaunch_status_skipped 0\nlaunch_status_unknown 0\nlaunch_time_duration 151724804\nlaunch_time_min_duration 0\nlaunch_time_max_duration 2018\nlaunch_time_sum_duration 6210\nlaunch_problems_product_defects 2\nlaunch_problems_test_defects 4\nlaunch_retries_retries 117\nlaunch_retries_run 26\n", 
 "history/categories-trend.json": "[{\"data\":{\"Product defects\":2,\"Test defects\":4}}]", 
 "history/duration-trend.json": "[{\"data\":{\"duration\":151724804}}]", 
 "history/history-trend.json": "[{\"data\":{\"failed\":2,\"broken\":4,\"skipped\":0,\"passed\":20,\"unknown\":0,\"total\":26}}]", 
 "history/history.json": "{\"5eb6b40c3fd338482b2ddfbbd0afcb56\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"9b47a930887b90e6\",\"status\":\"passed\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5}}]},\"44c20928331d32a6a3a17265cc43f975\":{\"statistic\":{\"failed\":0,\"broken\":1,\"skipped\":0,\"passed\":0,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"4d5227dfd64c8c2f\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x0000023566177280&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018}}]},\"b175c50ecbde153eef4dd01349cf1e04\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"9983dff8d8f5cc9e\",\"status\":\"passed\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5}}]},\"2dff4a9bee1cd78fd24b92fc336d5189\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"4506d4abe61d6cde\",\"status\":\"passed\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6}}]},\"c52b47aedbefdd9435ae90087b7849b3\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"629bc8ce5a745b9d\",\"status\":\"passed\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5}}]},\"354f8fc0730a8289cdb844d5db741a9b\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"fc2c79a47e8a0be2\",\"status\":\"passed\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8}}]},\"1272375df99bd519437487c4c7500a1b\":{\"statistic\":{\"failed\":0,\"broken\":1,\"skipped\":0,\"passed\":0,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"855ec7744f974935\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x00000235661CFE50&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014}}]},\"a8dd1ef98d7e8e52371cbc837c6b3fc2\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"e4749b9164c6442c\",\"status\":\"passed\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7}}]},\"4721b9645a0b1f04bafa5256b14beccb\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"7d2df5c839a0e516\",\"status\":\"passed\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22}}]},\"530e96ce51840b43ba9ed6286de20d0f\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"3eb22ea9f8d3f236\",\"status\":\"passed\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5}}]},\"1473ef8c673a8ff79040e670e3f8c75e\":{\"statistic\":{\"failed\":0,\"broken\":1,\"skipped\":0,\"passed\":0,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"ac58a6a18af5deec\",\"status\":\"broken\",\"statusDetails\":\"TypeError: list indices must be integers or slices, not str\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0}}]},\"ec4ffcbb8d9386289e6d1ac4e8004031\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"f83303d47c163767\",\"status\":\"passed\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5}}]},\"534af539ac1b8b1dd523b4647fb9aad0\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"d488b61a1a8655ff\",\"status\":\"passed\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6}}]},\"6a88d5ad1d7de6f85f78d77a9eb85c7f\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"dde8b1bbd7520535\",\"status\":\"passed\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21}}]},\"d6fdcb20142ceece4c419b7b04b54852\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"2943596d6e1f5d\",\"status\":\"passed\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4}}]},\"bf300d11c33de14c99079948840baa30\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"41358ff5883d29f4\",\"status\":\"passed\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5}}]},\"5dd2ad784c0ec9a9715bdafce56c6124\":{\"statistic\":{\"failed\":1,\"broken\":0,\"skipped\":0,\"passed\":0,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"6328afffd0309615\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 30001 == 0\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8}}]},\"c8b1d81f71261fd9b020151ebd96af7e\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"c02bfde9815c6999\",\"status\":\"passed\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8}}]},\"792ca8eb8ffd296dc312288cee8623be\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"1561815528981bde\",\"status\":\"passed\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6}}]},\"773ff28ad212c0f08f82000af8aa6a1f\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"d5a5b2c179710c79\",\"status\":\"passed\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7}}]},\"62a591e4bed58feff41f2aa0646771b2\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"c1ab83aa5974a5fe\",\"status\":\"passed\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6}}]},\"d61ad735f44141ef333ff8063b084e31\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"2804ffcd9a1cd236\",\"status\":\"passed\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5}}]},\"82854af4d9d1f8526142efab5c28f349\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"efbba17f563634ff\",\"status\":\"passed\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5}}]},\"9d80d20fab383dd25875073860987f1d\":{\"statistic\":{\"failed\":0,\"broken\":1,\"skipped\":0,\"passed\":0,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"37e0df3b92f127b0\",\"status\":\"broken\",\"statusDetails\":\"requests.exceptions.ConnectionError: HTTPConnectionPool(host='192.168.0.105', port=3000): Max retries exceeded with url: /api/user/login (Caused by NewConnectionError('&lt;urllib3.connection.HTTPConnection object at 0x000002356580D570&gt;: Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接。'))\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004}}]},\"db808937b6c6b4b8ae95bf2b74bb3853\":{\"statistic\":{\"failed\":1,\"broken\":0,\"skipped\":0,\"passed\":0,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"7cab27e631aff5d2\",\"status\":\"failed\",\"statusDetails\":\"AssertionError: assert 0 == 1001\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19}}]},\"bd779856aa83a555802f97899913cdfc\":{\"statistic\":{\"failed\":0,\"broken\":0,\"skipped\":0,\"passed\":1,\"unknown\":0,\"total\":1},\"items\":[{\"uid\":\"86d917d5f43504c4\",\"status\":\"passed\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6}}]}}", 
 "history/retry-trend.json": "[{\"data\":{\"run\":26,\"retry\":117}}]", 
 "plugins/behaviors/index.js": "'use strict';\n\nallure.api.addTranslation('en', {\n    tab: {\n        behaviors: {\n            name: 'Behaviors'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Features by stories',\n            showAll: 'show all'\n        }\n    }\n});\n\nallure.api.addTranslation('ru', {\n    tab: {\n        behaviors: {\n            name: 'Функциональность'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Функциональность',\n            showAll: 'показать все'\n        }\n    }\n});\n\nallure.api.addTranslation('zh', {\n    tab: {\n        behaviors: {\n            name: '功能'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: '特性场景',\n            showAll: '显示所有'\n        }\n    }\n});\n\nallure.api.addTranslation('de', {\n    tab: {\n        behaviors: {\n            name: 'Verhalten'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Features nach Stories',\n            showAll: 'Zeige alle'\n        }\n    }\n});\n\nallure.api.addTranslation('nl', {\n    tab: {\n        behaviors: {\n            name: 'Functionaliteit'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Features en story’s',\n            showAll: 'Toon alle'\n        }\n    }\n});\n\nallure.api.addTranslation('he', {\n    tab: {\n        behaviors: {\n            name: 'התנהגויות'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'תכונות לפי סיפורי משתמש',\n            showAll: 'הצג הכול'\n        }\n    }\n});\n\nallure.api.addTranslation('br', {\n    tab: {\n        behaviors: {\n            name: 'Comportamentos'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Funcionalidades por história',\n            showAll: 'Mostrar tudo'\n        }\n    }\n});\n\nallure.api.addTranslation('ja', {\n    tab: {\n        behaviors: {\n            name: '振る舞い'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'ストーリー別の機能',\n            showAll: '全て表示'\n        }\n    }\n});\n\nallure.api.addTranslation('es', {\n    tab: {\n        behaviors: {\n            name: 'Funcionalidades'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Funcionalidades por Historias de Usuario',\n            showAll: 'mostrar todo'\n        }\n    }\n});\n\nallure.api.addTranslation('kr', {\n    tab: {\n        behaviors: {\n            name: '동작'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: '스토리별 기능',\n            showAll: '전체 보기'\n        }\n    }\n});\n\nallure.api.addTranslation('fr', {\n    tab: {\n        behaviors: {\n            name: 'Comportements'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Thèmes par histoires',\n            showAll: 'Montrer tout'\n        }\n    }\n});\n\nallure.api.addTranslation('pl', {\n    tab: {\n        behaviors: {\n            name: 'Zachowania'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Funkcje według historii',\n            showAll: 'pokaż wszystko'\n        }\n    }\n});\n\nallure.api.addTranslation('az', {\n    tab: {\n        behaviors: {\n            name: 'Davranışlar'\n        }\n    },\n    widget: {\n        behaviors: {\n            name: 'Hekayələr üzrə xüsusiyyətlər',\n            showAll: 'hamısını göstər'\n        }\n    }\n});\n\nallure.api.addTab('behaviors', {\n    title: 'tab.behaviors.name', icon: 'fa fa-list',\n    route: 'behaviors(/)(:testGroup)(/)(:testResult)(/)(:testResultTab)(/)',\n    onEnter: (function (testGroup, testResult, testResultTab) {\n        return new allure.components.TreeLayout({\n            testGroup: testGroup,\n            testResult: testResult,\n            testResultTab: testResultTab,\n            tabName: 'tab.behaviors.name',\n            baseUrl: 'behaviors',\n            url: 'data/behaviors.json',\n            csvUrl: 'data/behaviors.csv'\n        });\n    })\n});\n\nallure.api.addWidget('widgets', 'behaviors', allure.components.WidgetStatusView.extend({\n    rowTag: 'a',\n    title: 'widget.behaviors.name',\n    baseUrl: 'behaviors',\n    showLinks: true\n}));\n", 
 "plugins/packages/index.js": "'use strict';\n\nallure.api.addTranslation('en', {\n    tab: {\n        packages: {\n            name: 'Packages'\n        }\n    }\n});\n\nallure.api.addTranslation('ru', {\n    tab: {\n        packages: {\n            name: 'Пакеты'\n        }\n    }\n});\n\nallure.api.addTranslation('zh', {\n    tab: {\n        packages: {\n            name: '包'\n        }\n    }\n});\n\nallure.api.addTranslation('de', {\n    tab: {\n        packages: {\n            name: 'Pakete'\n        }\n    }\n});\n\nallure.api.addTranslation('nl', {\n    tab: {\n        packages: {\n            name: 'Packages'\n        }\n    }\n});\n\nallure.api.addTranslation('he', {\n    tab: {\n        packages: {\n            name: 'חבילות'\n        }\n    }\n});\n\nallure.api.addTranslation('br', {\n    tab: {\n        packages: {\n            name: 'Pacotes'\n        }\n    }\n});\n\nallure.api.addTranslation('ja', {\n    tab: {\n        packages: {\n            name: 'パッケージ'\n        }\n    }\n});\n\nallure.api.addTranslation('es', {\n    tab: {\n        packages: {\n            name: 'Paquetes'\n        }\n    }\n});\n\nallure.api.addTranslation('kr', {\n    tab: {\n        packages: {\n            name: '패키지'\n        }\n    }\n});\n\nallure.api.addTranslation('fr', {\n    tab: {\n        packages: {\n            name: 'Paquets'\n        }\n    }\n});\n\nallure.api.addTranslation('pl', {\n    tab: {\n        packages: {\n            name: 'Pakiety'\n        }\n    }\n});\n\nallure.api.addTranslation('az', {\n    tab: {\n        packages: {\n            name: 'Paketlər'\n        }\n    }\n});\n\nallure.api.addTab('packages', {\n    title: 'tab.packages.name', icon: 'fa fa-align-left',\n    route: 'packages(/)(:testGroup)(/)(:testResult)(/)(:testResultTab)(/)',\n    onEnter: (function (testGroup, testResult, testResultTab) {\n        return new allure.components.TreeLayout({\n            testGroup: testGroup,\n            testResult: testResult,\n            testResultTab: testResultTab,\n            tabName: 'tab.packages.name',\n            baseUrl: 'packages',\n            url: 'data/packages.json'\n        });\n    })\n});\n", 
 "plugins/screen-diff/index.js": "(function () {\n    var settings = allure.getPluginSettings('screen-diff', { diffType: 'diff' });\n\n    function renderImage(src) {\n        return (\n            '&lt;div class=\"screen-diff__container\"&gt;' +\n            '&lt;img class=\"screen-diff__image\" src=\"' +\n            src +\n            '\"&gt;' +\n            '&lt;/div&gt;'\n        );\n    }\n\n    function findImage(data, name) {\n        if (data.testStage && data.testStage.attachments) {\n            var matchedImage = data.testStage.attachments.filter(function (attachment) {\n                return attachment.name === name;\n            })[0];\n            if (matchedImage) {\n                return 'data/attachments/' + matchedImage.source;\n            }\n        }\n        return null;\n    }\n\n    function renderDiffContent(type, diffImage, actualImage, expectedImage) {\n        if (type === 'diff') {\n            if (diffImage) {\n                return renderImage(diffImage);\n            }\n        }\n        if (type === 'overlay' && expectedImage) {\n            return (\n                '&lt;div class=\"screen-diff__overlay screen-diff__container\"&gt;' +\n                '&lt;img class=\"screen-diff__image\" src=\"' +\n                expectedImage +\n                '\"&gt;' +\n                '&lt;div class=\"screen-diff__image-over\"&gt;' +\n                '&lt;img class=\"screen-diff__image\" src=\"' +\n                actualImage +\n                '\"&gt;' +\n                '&lt;/div&gt;' +\n                '&lt;/div&gt;'\n            );\n        }\n        if (actualImage) {\n            return renderImage(actualImage);\n        }\n        return 'No diff data provided';\n    }\n\n    var TestResultView = Backbone.Marionette.View.extend({\n        regions: {\n            subView: '.screen-diff-view',\n        },\n        template: function () {\n            return '&lt;div class=\"screen-diff-view\"&gt;&lt;/div&gt;';\n        },\n        onRender: function () {\n            var data = this.model.toJSON();\n            var testType = data.labels.filter(function (label) {\n                return label.name === 'testType';\n            })[0];\n            var diffImage = findImage(data, 'diff');\n            var actualImage = findImage(data, 'actual');\n            var expectedImage = findImage(data, 'expected');\n            if (!testType || testType.value !== 'screenshotDiff') {\n                return;\n            }\n            this.showChildView(\n                'subView',\n                new ScreenDiffView({\n                    diffImage: diffImage,\n                    actualImage: actualImage,\n                    expectedImage: expectedImage,\n                }),\n            );\n        },\n    });\n    var ErrorView = Backbone.Marionette.View.extend({\n        templateContext: function () {\n            return this.options;\n        },\n        template: function (data) {\n            return '&lt;pre class=\"screen-diff-error\"&gt;' + data.error + '&lt;/pre&gt;';\n        },\n    });\n    var AttachmentView = Backbone.Marionette.View.extend({\n        regions: {\n            subView: '.screen-diff-view',\n        },\n        template: function () {\n            return '&lt;div class=\"screen-diff-view\"&gt;&lt;/div&gt;';\n        },\n        onRender: function () {\n            jQuery\n                .getJSON(this.options.sourceUrl)\n                .then(this.renderScreenDiffView.bind(this), this.renderErrorView.bind(this));\n        },\n        renderErrorView: function (error) {\n            console.log(error);\n            this.showChildView(\n                'subView',\n                new ErrorView({\n                    error: error.statusText,\n                }),\n            );\n        },\n        renderScreenDiffView: function (data) {\n            this.showChildView(\n                'subView',\n                new ScreenDiffView({\n                    diffImage: data.diff,\n                    actualImage: data.actual,\n                    expectedImage: data.expected,\n                }),\n            );\n        },\n    });\n\n    var ScreenDiffView = Backbone.Marionette.View.extend({\n        className: 'pane__section',\n        events: function () {\n            return {\n                ['click [name=\"screen-diff-type-' + this.cid + '\"]']: 'onDiffTypeChange',\n                'mousemove .screen-diff__overlay': 'onOverlayMove',\n            };\n        },\n        initialize: function (options) {\n            this.diffImage = options.diffImage;\n            this.actualImage = options.actualImage;\n            this.expectedImage = options.expectedImage;\n            this.radioName = 'screen-diff-type-' + this.cid;\n        },\n        templateContext: function () {\n            return {\n                diffType: settings.get('diffType'),\n                diffImage: this.diffImage,\n                actualImage: this.actualImage,\n                expectedImage: this.expectedImage,\n                radioName: this.radioName,\n            };\n        },\n        template: function (data) {\n            if (!data.diffImage && !data.actualImage && !data.expectedImage) {\n                return '';\n            }\n\n            return (\n                '&lt;h3 class=\"pane__section-title\"&gt;Screen Diff&lt;/h3&gt;' +\n                '&lt;div class=\"screen-diff__content\"&gt;' +\n                '&lt;div class=\"screen-diff__switchers\"&gt;' +\n                '&lt;label&gt;&lt;input type=\"radio\" name=\"' +\n                data.radioName +\n                '\" value=\"diff\"&gt; Show diff&lt;/label&gt;' +\n                '&lt;label&gt;&lt;input type=\"radio\" name=\"' +\n                data.radioName +\n                '\" value=\"overlay\"&gt; Show overlay&lt;/label&gt;' +\n                '&lt;/div&gt;' +\n                renderDiffContent(\n                    data.diffType,\n                    data.diffImage,\n                    data.actualImage,\n                    data.expectedImage,\n                ) +\n                '&lt;/div&gt;'\n            );\n        },\n        adjustImageSize: function (event) {\n            var overImage = this.$(event.target);\n            overImage.width(overImage.width());\n        },\n        onRender: function () {\n            const diffType = settings.get('diffType');\n            this.$('[name=\"' + this.radioName + '\"][value=\"' + diffType + '\"]').prop(\n                'checked',\n                true,\n            );\n            if (diffType === 'overlay') {\n                this.$('.screen-diff__image-over img').on('load', this.adjustImageSize.bind(this));\n            }\n        },\n        onOverlayMove: function (event) {\n            var pageX = event.pageX;\n            var containerScroll = this.$('.screen-diff__container').scrollLeft();\n            var elementX = event.currentTarget.getBoundingClientRect().left;\n            var delta = pageX - elementX + containerScroll;\n            this.$('.screen-diff__image-over').width(delta);\n        },\n        onDiffTypeChange: function (event) {\n            settings.save('diffType', event.target.value);\n            this.render();\n        },\n    });\n    allure.api.addTestResultBlock(TestResultView, { position: 'before' });\n    allure.api.addAttachmentViewer('application/vnd.allure.image.diff', {\n        View: AttachmentView,\n        icon: 'fa fa-exchange',\n    });\n})();\n", 
 "plugins/screen-diff/styles.css": ".screen-diff__switchers {\n  margin-bottom: 1em;\n}\n\n.screen-diff__switchers label + label {\n  margin-left: 1em;\n}\n\n.screen-diff__overlay {\n  position: relative;\n  cursor: col-resize;\n}\n\n.screen-diff__container {\n  overflow-x: auto;\n}\n\n.screen-diff__image-over {\n  top: 0;\n  left: 0;\n  bottom: 0;\n  background: #fff;\n  position: absolute;\n  overflow: hidden;\n  box-shadow: 2px 0 1px -1px #aaa;\n}\n\n.screen-diff-error {\n  color: #fd5a3e;\n}\n", 
 "widgets/behaviors.json": "{\"total\":26,\"items\":[]}", 
 "widgets/categories-trend.json": "[{\"data\":{\"Product defects\":2,\"Test defects\":4}}]", 
 "widgets/categories.json": "{\"total\":2,\"items\":[{\"uid\":\"8fb3a91ba5aaf9de24cc8a92edc82b5d\",\"name\":\"Product defects\",\"statistic\":{\"failed\":2,\"broken\":0,\"skipped\":0,\"passed\":0,\"unknown\":0,\"total\":2}},{\"uid\":\"bdbf199525818fae7a8651db9eafe741\",\"name\":\"Test defects\",\"statistic\":{\"failed\":0,\"broken\":4,\"skipped\":0,\"passed\":0,\"unknown\":0,\"total\":4}}]}", 
 "widgets/duration-trend.json": "[{\"data\":{\"duration\":151724804}}]", 
 "widgets/duration.json": "[{\"uid\":\"c02bfde9815c6999\",\"name\":\"test_addNewAddress[result1]\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"e4749b9164c6442c\",\"name\":\"test_updateAddressByAid[result0]\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"7cab27e631aff5d2\",\"name\":\"test_register[result0]\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"status\":\"failed\",\"severity\":\"normal\"},{\"uid\":\"c1ab83aa5974a5fe\",\"name\":\"test_login[res0]\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"9b47a930887b90e6\",\"name\":\"test_updateAddressByAid[result1]\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"6328afffd0309615\",\"name\":\"test_order_submit[result1]\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"status\":\"failed\",\"severity\":\"normal\"},{\"uid\":\"ac58a6a18af5deec\",\"name\":\"test_login\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"86d917d5f43504c4\",\"name\":\"test_getDeafultAddress[result0]\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"2804ffcd9a1cd236\",\"name\":\"test_getAddressByAid[result0]\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"dde8b1bbd7520535\",\"name\":\"test_order_getall[result0]\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"d5a5b2c179710c79\",\"name\":\"test_addNewAddress[result0]\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"41358ff5883d29f4\",\"name\":\"test_delAddressByAid[result1]\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"4d5227dfd64c8c2f\",\"name\":\"test_login[result2]\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"f83303d47c163767\",\"name\":\"test_login[res2]\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"efbba17f563634ff\",\"name\":\"test_register[res0]\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"fc2c79a47e8a0be2\",\"name\":\"test_order_submit[result0]\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"4506d4abe61d6cde\",\"name\":\"test_register[res1]\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"2943596d6e1f5d\",\"name\":\"test_getAddressByAid[result1]\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"1561815528981bde\",\"name\":\"test_getsAddressList[result0]\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"3eb22ea9f8d3f236\",\"name\":\"test_login[res1]\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"9983dff8d8f5cc9e\",\"name\":\"test_register[result2]\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"7d2df5c839a0e516\",\"name\":\"test_register[result1]\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"37e0df3b92f127b0\",\"name\":\"test_login[result1]\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"d488b61a1a8655ff\",\"name\":\"test_register[res2]\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"629bc8ce5a745b9d\",\"name\":\"test_delAddressByAid[result0]\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"855ec7744f974935\",\"name\":\"test_login[result0]\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"status\":\"broken\",\"severity\":\"normal\"}]", 
 "widgets/environment.json": "[]", 
 "widgets/executors.json": "[]", 
 "widgets/history-trend.json": "[{\"data\":{\"failed\":2,\"broken\":4,\"skipped\":0,\"passed\":20,\"unknown\":0,\"total\":26}}]", 
 "widgets/launch.json": "[]", 
 "widgets/retry-trend.json": "[{\"data\":{\"run\":26,\"retry\":117}}]", 
 "widgets/severity.json": "[{\"uid\":\"3eb22ea9f8d3f236\",\"name\":\"test_login[res1]\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"2943596d6e1f5d\",\"name\":\"test_getAddressByAid[result1]\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"dde8b1bbd7520535\",\"name\":\"test_order_getall[result0]\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"37e0df3b92f127b0\",\"name\":\"test_login[result1]\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"ac58a6a18af5deec\",\"name\":\"test_login\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"86d917d5f43504c4\",\"name\":\"test_getDeafultAddress[result0]\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"2804ffcd9a1cd236\",\"name\":\"test_getAddressByAid[result0]\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"d488b61a1a8655ff\",\"name\":\"test_register[res2]\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"855ec7744f974935\",\"name\":\"test_login[result0]\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"4506d4abe61d6cde\",\"name\":\"test_register[res1]\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"9983dff8d8f5cc9e\",\"name\":\"test_register[result2]\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"629bc8ce5a745b9d\",\"name\":\"test_delAddressByAid[result0]\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"7cab27e631aff5d2\",\"name\":\"test_register[result0]\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"status\":\"failed\",\"severity\":\"normal\"},{\"uid\":\"7d2df5c839a0e516\",\"name\":\"test_register[result1]\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"e4749b9164c6442c\",\"name\":\"test_updateAddressByAid[result0]\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"c1ab83aa5974a5fe\",\"name\":\"test_login[res0]\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"9b47a930887b90e6\",\"name\":\"test_updateAddressByAid[result1]\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"6328afffd0309615\",\"name\":\"test_order_submit[result1]\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"status\":\"failed\",\"severity\":\"normal\"},{\"uid\":\"4d5227dfd64c8c2f\",\"name\":\"test_login[result2]\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"1561815528981bde\",\"name\":\"test_getsAddressList[result0]\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"c02bfde9815c6999\",\"name\":\"test_addNewAddress[result1]\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"fc2c79a47e8a0be2\",\"name\":\"test_order_submit[result0]\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"efbba17f563634ff\",\"name\":\"test_register[res0]\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"f83303d47c163767\",\"name\":\"test_login[res2]\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"41358ff5883d29f4\",\"name\":\"test_delAddressByAid[result1]\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"d5a5b2c179710c79\",\"name\":\"test_addNewAddress[result0]\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7},\"status\":\"passed\",\"severity\":\"normal\"}]", 
 "widgets/status-chart.json": "[{\"uid\":\"c02bfde9815c6999\",\"name\":\"test_addNewAddress[result1]\",\"time\":{\"start\":1706176287696,\"stop\":1706176287704,\"duration\":8},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"e4749b9164c6442c\",\"name\":\"test_updateAddressByAid[result0]\",\"time\":{\"start\":1706176287719,\"stop\":1706176287726,\"duration\":7},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"7cab27e631aff5d2\",\"name\":\"test_register[result0]\",\"time\":{\"start\":1706174785104,\"stop\":1706174785123,\"duration\":19},\"status\":\"failed\",\"severity\":\"normal\"},{\"uid\":\"c1ab83aa5974a5fe\",\"name\":\"test_login[res0]\",\"time\":{\"start\":1706176287919,\"stop\":1706176287925,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"9b47a930887b90e6\",\"name\":\"test_updateAddressByAid[result1]\",\"time\":{\"start\":1706176287729,\"stop\":1706176287734,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"6328afffd0309615\",\"name\":\"test_order_submit[result1]\",\"time\":{\"start\":1706176287772,\"stop\":1706176287780,\"duration\":8},\"status\":\"failed\",\"severity\":\"normal\"},{\"uid\":\"ac58a6a18af5deec\",\"name\":\"test_login\",\"time\":{\"start\":1706120658304,\"stop\":1706120658304,\"duration\":0},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"86d917d5f43504c4\",\"name\":\"test_getDeafultAddress[result0]\",\"time\":{\"start\":1706176287752,\"stop\":1706176287758,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"2804ffcd9a1cd236\",\"name\":\"test_getAddressByAid[result0]\",\"time\":{\"start\":1706176287706,\"stop\":1706176287711,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"dde8b1bbd7520535\",\"name\":\"test_order_getall[result0]\",\"time\":{\"start\":1706176287896,\"stop\":1706176287917,\"duration\":21},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"d5a5b2c179710c79\",\"name\":\"test_addNewAddress[result0]\",\"time\":{\"start\":1706176287686,\"stop\":1706176287693,\"duration\":7},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"41358ff5883d29f4\",\"name\":\"test_delAddressByAid[result1]\",\"time\":{\"start\":1706176287744,\"stop\":1706176287749,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"4d5227dfd64c8c2f\",\"name\":\"test_login[result2]\",\"time\":{\"start\":1706024567386,\"stop\":1706024569404,\"duration\":2018},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"f83303d47c163767\",\"name\":\"test_login[res2]\",\"time\":{\"start\":1706176287934,\"stop\":1706176287939,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"efbba17f563634ff\",\"name\":\"test_register[res0]\",\"time\":{\"start\":1706176287941,\"stop\":1706176287946,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"fc2c79a47e8a0be2\",\"name\":\"test_order_submit[result0]\",\"time\":{\"start\":1706176287761,\"stop\":1706176287769,\"duration\":8},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"4506d4abe61d6cde\",\"name\":\"test_register[res1]\",\"time\":{\"start\":1706176287949,\"stop\":1706176287955,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"2943596d6e1f5d\",\"name\":\"test_getAddressByAid[result1]\",\"time\":{\"start\":1706176287713,\"stop\":1706176287717,\"duration\":4},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"1561815528981bde\",\"name\":\"test_getsAddressList[result0]\",\"time\":{\"start\":1706176287677,\"stop\":1706176287683,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"3eb22ea9f8d3f236\",\"name\":\"test_login[res1]\",\"time\":{\"start\":1706176287927,\"stop\":1706176287932,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"9983dff8d8f5cc9e\",\"name\":\"test_register[result2]\",\"time\":{\"start\":1706174785279,\"stop\":1706174785284,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"7d2df5c839a0e516\",\"name\":\"test_register[result1]\",\"time\":{\"start\":1706174785254,\"stop\":1706174785276,\"duration\":22},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"37e0df3b92f127b0\",\"name\":\"test_login[result1]\",\"time\":{\"start\":1706024565277,\"stop\":1706024567281,\"duration\":2004},\"status\":\"broken\",\"severity\":\"normal\"},{\"uid\":\"d488b61a1a8655ff\",\"name\":\"test_register[res2]\",\"time\":{\"start\":1706176287957,\"stop\":1706176287963,\"duration\":6},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"629bc8ce5a745b9d\",\"name\":\"test_delAddressByAid[result0]\",\"time\":{\"start\":1706176287737,\"stop\":1706176287742,\"duration\":5},\"status\":\"passed\",\"severity\":\"normal\"},{\"uid\":\"855ec7744f974935\",\"name\":\"test_login[result0]\",\"time\":{\"start\":1706024563159,\"stop\":1706024565173,\"duration\":2014},\"status\":\"broken\",\"severity\":\"normal\"}]", 
 "widgets/suites.json": "{\"total\":1,\"items\":[{\"uid\":\"b51346658ccdb9db01a6b5f6c12deab1\",\"name\":\"testcases\",\"statistic\":{\"failed\":2,\"broken\":4,\"skipped\":0,\"passed\":20,\"unknown\":0,\"total\":26}}]}", 
 "widgets/summary.json": "{\"reportName\":\"Allure Report\",\"testRuns\":[],\"statistic\":{\"failed\":2,\"broken\":4,\"skipped\":0,\"passed\":20,\"unknown\":0,\"total\":26},\"time\":{\"start\":1706024563159,\"stop\":1706176287963,\"duration\":151724804,\"minDuration\":0,\"maxDuration\":2018,\"sumDuration\":6210}}", 
};
    var server = sinon.fakeServer.create();

                server.respondWith("GET", "data/behaviors.csv", [
                      200, { "Content-Type": "text/csv" }, server_data["data/behaviors.csv"],
                ]);
            
                server.respondWith("GET", "data/behaviors.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/behaviors.json"],
                ]);
            
                server.respondWith("GET", "data/categories.csv", [
                      200, { "Content-Type": "text/csv" }, server_data["data/categories.csv"],
                ]);
            
                server.respondWith("GET", "data/categories.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/categories.json"],
                ]);
            
                server.respondWith("GET", "data/packages.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/packages.json"],
                ]);
            
                server.respondWith("GET", "data/suites.csv", [
                      200, { "Content-Type": "text/csv" }, server_data["data/suites.csv"],
                ]);
            
                server.respondWith("GET", "data/suites.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/suites.json"],
                ]);
            
                server.respondWith("GET", "data/timeline.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/timeline.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/121364db5876c71d.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/121364db5876c71d.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/12e98e1e9a8f5bbb.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/12e98e1e9a8f5bbb.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/1561815528981bde.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/1561815528981bde.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/18600a6b8be8b31d.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/18600a6b8be8b31d.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/19216d256fff3d6c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/19216d256fff3d6c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/21370f3ffbc5706.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/21370f3ffbc5706.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/23803f77f364625.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/23803f77f364625.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/239377fefe608f69.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/239377fefe608f69.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/24410c609482562.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/24410c609482562.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/2604ce0ea6dcf02e.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/2604ce0ea6dcf02e.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/27d27eddc3305046.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/27d27eddc3305046.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/2804ffcd9a1cd236.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/2804ffcd9a1cd236.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/2943596d6e1f5d.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/2943596d6e1f5d.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/2bf22827887d5029.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/2bf22827887d5029.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/31d31da53575fa22.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/31d31da53575fa22.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/32b06e0816e3d789.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/32b06e0816e3d789.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/34643e193c1bea9b.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/34643e193c1bea9b.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/3765d8b8a8297a37.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/3765d8b8a8297a37.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/37e0df3b92f127b0.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/37e0df3b92f127b0.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/37e228441c4c3f65.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/37e228441c4c3f65.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/3e09bbfa1e0e9c33.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/3e09bbfa1e0e9c33.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/3eb22ea9f8d3f236.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/3eb22ea9f8d3f236.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/3ec5a0aca74c5be2.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/3ec5a0aca74c5be2.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/41358ff5883d29f4.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/41358ff5883d29f4.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/41b051b435ebef16.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/41b051b435ebef16.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/43a1ca1d96b6b40c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/43a1ca1d96b6b40c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/44b23c4ed276fd3.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/44b23c4ed276fd3.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/44cdd8ea0e91484f.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/44cdd8ea0e91484f.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/4506d4abe61d6cde.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/4506d4abe61d6cde.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/45b81bc67a25584.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/45b81bc67a25584.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/463a5bd2f13d8a62.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/463a5bd2f13d8a62.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/4880c65bfdeaafd4.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/4880c65bfdeaafd4.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/48ac857847062f9.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/48ac857847062f9.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/4a1618bd78fb3d9a.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/4a1618bd78fb3d9a.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/4a630288ecb6b240.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/4a630288ecb6b240.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/4c56e82b4db47841.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/4c56e82b4db47841.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/4d5227dfd64c8c2f.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/4d5227dfd64c8c2f.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/5102fb4d71ab99d.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/5102fb4d71ab99d.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/57b26aeafef0c82.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/57b26aeafef0c82.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/58295da410e8d5e0.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/58295da410e8d5e0.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/58417ae0310d14ae.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/58417ae0310d14ae.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/58f88f2609cf025e.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/58f88f2609cf025e.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/59aa65b9076491.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/59aa65b9076491.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/5fbdcc35f74d0d4d.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/5fbdcc35f74d0d4d.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/617a96d71a86238e.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/617a96d71a86238e.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/6240318d33740dc3.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/6240318d33740dc3.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/629bc8ce5a745b9d.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/629bc8ce5a745b9d.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/62b801e2b9af5ae6.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/62b801e2b9af5ae6.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/6328afffd0309615.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/6328afffd0309615.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/6668ec183649f57a.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/6668ec183649f57a.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/68ccc2a7d497169c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/68ccc2a7d497169c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/6c14fc9a6931898e.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/6c14fc9a6931898e.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/6ebed51a52a9b14b.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/6ebed51a52a9b14b.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/718f6be754103361.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/718f6be754103361.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/71d6c83f0b0714bf.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/71d6c83f0b0714bf.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/7331757ec1317ef6.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/7331757ec1317ef6.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/777ee1a42b2d201a.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/777ee1a42b2d201a.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/7cab27e631aff5d2.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/7cab27e631aff5d2.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/7d2df5c839a0e516.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/7d2df5c839a0e516.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/7d6899310bfd0f72.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/7d6899310bfd0f72.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/7e2d167039e5082b.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/7e2d167039e5082b.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/7f25b47d29fdd0b8.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/7f25b47d29fdd0b8.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/823e5019b6872caf.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/823e5019b6872caf.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/829f1fa11d3b9d89.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/829f1fa11d3b9d89.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/82d31ee73066ea4d.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/82d31ee73066ea4d.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/847e00c0573453a3.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/847e00c0573453a3.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/855ec7744f974935.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/855ec7744f974935.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/86453f582e605df4.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/86453f582e605df4.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/86d917d5f43504c4.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/86d917d5f43504c4.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/8834dc40085b5894.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/8834dc40085b5894.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/8862ef4f323535cf.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/8862ef4f323535cf.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/8b48dd6cfa60dcf1.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/8b48dd6cfa60dcf1.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/8c63ea0716a5841c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/8c63ea0716a5841c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/8c81b6cfd82f2126.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/8c81b6cfd82f2126.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/8f95947b12dc457d.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/8f95947b12dc457d.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/93128bc2f24ea57e.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/93128bc2f24ea57e.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/93dbb0360b0f1050.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/93dbb0360b0f1050.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/96378aa755ea26e9.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/96378aa755ea26e9.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/9802d0da6fbd139f.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/9802d0da6fbd139f.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/992369678935f076.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/992369678935f076.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/99551c5f19cb7224.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/99551c5f19cb7224.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/9983dff8d8f5cc9e.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/9983dff8d8f5cc9e.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/9a2a474633554637.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/9a2a474633554637.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/9b47a930887b90e6.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/9b47a930887b90e6.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/9ddd3edb6b9f1081.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/9ddd3edb6b9f1081.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/a2fc69097003cf5c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/a2fc69097003cf5c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/a42e21610ad5fe5b.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/a42e21610ad5fe5b.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/a4fcf360eb4a29ad.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/a4fcf360eb4a29ad.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/a564f466e85d11d2.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/a564f466e85d11d2.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/a605a95d5e451326.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/a605a95d5e451326.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/a726103007684711.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/a726103007684711.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/aac99276ba804081.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/aac99276ba804081.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/ab68508ce08448.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/ab68508ce08448.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/ac58a6a18af5deec.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/ac58a6a18af5deec.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/b0de72f0fe71afe3.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/b0de72f0fe71afe3.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/b3ee8f0eec85491b.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/b3ee8f0eec85491b.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/b74346d6a95334ac.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/b74346d6a95334ac.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/b7c252fb9cb31156.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/b7c252fb9cb31156.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/b8627919718d53a8.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/b8627919718d53a8.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/bbe95b736bb987cd.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/bbe95b736bb987cd.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/bc1d41551a77e65e.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/bc1d41551a77e65e.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/bee54566c8d789a1.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/bee54566c8d789a1.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/bef61f13e3947915.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/bef61f13e3947915.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/bfe4fb7ad9acbe71.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/bfe4fb7ad9acbe71.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/c02bfde9815c6999.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/c02bfde9815c6999.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/c0c50ee6e50d4506.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/c0c50ee6e50d4506.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/c1ab83aa5974a5fe.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/c1ab83aa5974a5fe.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/c1d370af762a3c42.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/c1d370af762a3c42.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/c5eb365d82d86cd5.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/c5eb365d82d86cd5.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/c646cb618c139539.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/c646cb618c139539.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/c90469a05eb30fc3.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/c90469a05eb30fc3.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/ca3dc772fc00a28e.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/ca3dc772fc00a28e.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/caca9913474a0200.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/caca9913474a0200.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/cf35e8a285e37e3c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/cf35e8a285e37e3c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/d105b1c5083274ac.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/d105b1c5083274ac.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/d1e3f0d1cad9ed5.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/d1e3f0d1cad9ed5.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/d306ab9e57f3b994.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/d306ab9e57f3b994.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/d488b61a1a8655ff.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/d488b61a1a8655ff.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/d53f6d70a9c81d71.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/d53f6d70a9c81d71.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/d5a5b2c179710c79.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/d5a5b2c179710c79.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/d5b7145fa232099c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/d5b7145fa232099c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/d5f5676e825a95df.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/d5f5676e825a95df.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/db71788f163efb6b.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/db71788f163efb6b.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/dc332251f910a23b.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/dc332251f910a23b.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/dde8b1bbd7520535.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/dde8b1bbd7520535.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/deccf557b865d595.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/deccf557b865d595.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/e4749b9164c6442c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/e4749b9164c6442c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/e48f4a8ea6ffe578.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/e48f4a8ea6ffe578.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/e5fd9ed04dac6302.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/e5fd9ed04dac6302.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/eb5d88584cf2b3a5.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/eb5d88584cf2b3a5.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/ebd5a39f8564059c.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/ebd5a39f8564059c.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/efbba17f563634ff.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/efbba17f563634ff.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/f2cad0279515ab48.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/f2cad0279515ab48.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/f310db1fc79fd9d5.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/f310db1fc79fd9d5.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/f3ddde2fc782ecd.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/f3ddde2fc782ecd.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/f41f8f3868551db9.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/f41f8f3868551db9.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/f83303d47c163767.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/f83303d47c163767.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/faf51b4aff6cbf19.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/faf51b4aff6cbf19.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/faf5ca61d101cd27.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/faf5ca61d101cd27.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/fbd00a4f1636ad74.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/fbd00a4f1636ad74.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/fc2c79a47e8a0be2.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/fc2c79a47e8a0be2.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/fdbdaea3ad155ee1.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/fdbdaea3ad155ee1.json"],
                ]);
            
                server.respondWith("GET", "data/test-cases/fe2fa76f95d27044.json", [
                      200, { "Content-Type": "application/json" }, server_data["data/test-cases/fe2fa76f95d27044.json"],
                ]);
            
                server.respondWith("GET", "export/influxDbData.txt", [
                      200, { "Content-Type": "text/plain;charset=UTF-8" }, server_data["export/influxDbData.txt"],
                ]);
            
                server.respondWith("GET", "export/mail.html", [
                      200, { "Content-Type": "text/html" }, server_data["export/mail.html"],
                ]);
            
                server.respondWith("GET", "export/prometheusData.txt", [
                      200, { "Content-Type": "text/plain;charset=UTF-8" }, server_data["export/prometheusData.txt"],
                ]);
            
                server.respondWith("GET", "history/categories-trend.json", [
                      200, { "Content-Type": "application/json" }, server_data["history/categories-trend.json"],
                ]);
            
                server.respondWith("GET", "history/duration-trend.json", [
                      200, { "Content-Type": "application/json" }, server_data["history/duration-trend.json"],
                ]);
            
                server.respondWith("GET", "history/history-trend.json", [
                      200, { "Content-Type": "application/json" }, server_data["history/history-trend.json"],
                ]);
            
                server.respondWith("GET", "history/history.json", [
                      200, { "Content-Type": "application/json" }, server_data["history/history.json"],
                ]);
            
                server.respondWith("GET", "history/retry-trend.json", [
                      200, { "Content-Type": "application/json" }, server_data["history/retry-trend.json"],
                ]);
            
                server.respondWith("GET", "plugins/behaviors/index.js", [
                      200, { "Content-Type": "application/javascript" }, server_data["plugins/behaviors/index.js"],
                ]);
            
                server.respondWith("GET", "plugins/packages/index.js", [
                      200, { "Content-Type": "application/javascript" }, server_data["plugins/packages/index.js"],
                ]);
            
                server.respondWith("GET", "plugins/screen-diff/index.js", [
                      200, { "Content-Type": "application/javascript" }, server_data["plugins/screen-diff/index.js"],
                ]);
            
                server.respondWith("GET", "plugins/screen-diff/styles.css", [
                      200, { "Content-Type": "text/css" }, server_data["plugins/screen-diff/styles.css"],
                ]);
            
                server.respondWith("GET", "widgets/behaviors.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/behaviors.json"],
                ]);
            
                server.respondWith("GET", "widgets/categories-trend.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/categories-trend.json"],
                ]);
            
                server.respondWith("GET", "widgets/categories.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/categories.json"],
                ]);
            
                server.respondWith("GET", "widgets/duration-trend.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/duration-trend.json"],
                ]);
            
                server.respondWith("GET", "widgets/duration.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/duration.json"],
                ]);
            
                server.respondWith("GET", "widgets/environment.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/environment.json"],
                ]);
            
                server.respondWith("GET", "widgets/executors.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/executors.json"],
                ]);
            
                server.respondWith("GET", "widgets/history-trend.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/history-trend.json"],
                ]);
            
                server.respondWith("GET", "widgets/launch.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/launch.json"],
                ]);
            
                server.respondWith("GET", "widgets/retry-trend.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/retry-trend.json"],
                ]);
            
                server.respondWith("GET", "widgets/severity.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/severity.json"],
                ]);
            
                server.respondWith("GET", "widgets/status-chart.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/status-chart.json"],
                ]);
            
                server.respondWith("GET", "widgets/suites.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/suites.json"],
                ]);
            
                server.respondWith("GET", "widgets/summary.json", [
                      200, { "Content-Type": "application/json" }, server_data["widgets/summary.json"],
                ]);
            server.autoRespond = true;